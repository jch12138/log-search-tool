<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥å¿—èšåˆæœç´¢</title>
    <link rel="icon" href="/static/icons/favicon-search.svg" />

    <!-- æœ¬åœ°èµ„æº -->
    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="/static/css/element-plus.css" />
    <!-- Prism.js CSSä¸»é¢˜ -->
    <link rel="stylesheet" href="/static/css/prism-okaidia.min.css" />
    <!-- è‡ªå®šä¹‰CSS -->
    <link rel="stylesheet" href="/static/fonts/microsoft-yahei.css" />
    <link rel="stylesheet" href="/static/css/main.css" />
    <link rel="stylesheet" href="/static/css/groups.css" />
    <link rel="stylesheet" href="/static/css/search.css" />
    <link rel="stylesheet" href="/static/css/results.css" />
    <!-- ç´§å‡‘æ ·å¼è¦†ç›– -->
    <link rel="stylesheet" href="/static/css/compact.css" />
    <!-- Index page specific extracted styles -->
    <link rel="stylesheet" href="/static/css/index.css" />
    <!-- Log results component styles -->
    <link rel="stylesheet" href="/static/css/log-results.css" />
    <!-- Utilities -->
    <link rel="stylesheet" href="/static/css/utilities.css" />
    
    <!-- æœ¬åœ°JavaScriptåº“ -->
    <script src="/static/js/vendor/vue.global.js"></script>
    <script src="/static/js/vendor/element-plus.js"></script>
    <script src="/static/js/vendor/axios.min.js"></script>
    <!-- Prism.jsåº“ -->
    <script src="/static/js/vendor/prism-core.min.js"></script>
    <script src="/static/js/vendor/prism-markup.min.js"></script>
    <script src="/static/js/vendor/prism-clike.min.js"></script>
    <script src="/static/js/vendor/prism-javascript.min.js"></script>
    <script src="/static/js/vendor/prism-json.min.js"></script>
    <script src="/static/js/vendor/prism-sql.min.js"></script>
    <script src="/static/js/vendor/prism-xml-doc.min.js"></script>
    <!-- LogSearchResults ç»„ä»¶ -->
    <script src="/static/js/LogSearchResults.js"></script>

</head>

<body>
    <script>window.APP_PAGE="{{ page|default('') }}";</script>
    <div id="app">
        <div class="app-container">


            <!-- ä¸»å†…å®¹åŒºåŸŸ -->
            <div class="main-content">
                <!-- å·¦ä¾§æ—¥å¿—åˆ—è¡¨ -->
                <div class="left-panel">
                    <div class="panel-header">
                        <h3>ğŸ” æ—¥å¿—èšåˆæœç´¢</h3>
                    </div>
                    <div class="log-list" v-loading="logsLoading">
                        <div v-if="logs.length === 0 && !logsLoading" class="empty-state">
                            <div>æš‚æ— æ—¥å¿—é…ç½®</div>
                        </div>
                        
                        <!-- åˆ†ç»„æ˜¾ç¤º -->
                        <div v-for="group in groupedLogs" :key="group.name" class="log-group">
                            <!-- åˆ†ç»„æ ‡é¢˜ -->
                            <div class="group-header" @click="toggleGroup(group.name)">
                                <span class="group-name">[[ group.name ]]</span>
                                <span class="group-count">([[ group.logs.length ]])</span>
                                <span class="toggle-icon" :class="{ collapsed: group.isCollapsed }">â–¼</span>
                            </div>
                            
                            <!-- åˆ†ç»„å†…çš„æ—¥å¿—åˆ—è¡¨ -->
                            <div v-show="!group.isCollapsed" class="group-content">
                                <div v-for="log in group.logs" :key="log.name" class="log-item"
                                    :class="{ active: selectedLog?.name === log.name }" @click="selectLog(log)">
                                    <h4>[[ log.name ]]</h4>
                                    <p>[[ log.description || 'æš‚æ— æè¿°' ]]</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- æ›´å¤šåŠŸèƒ½æŒ‰é’® -->
                    <!-- ä¸´æ—¶éšè—æ›´å¤šå·¥å…·å…¥å£: ç”¨æˆ·è¯·æ±‚ "æš‚æ—¶éšè—æ›´å¤šå·¥å…·å…¥å£" -->
                    <div class="more-actions" style="display:none;" aria-hidden="true">
                        <button class="more-button" @click="toggleMoreMenu" :class="{ active: showMoreMenu }">
                            <span class="more-icon">âš™ï¸</span>
                            <span class="more-text">æ›´å¤šåŠŸèƒ½</span>
                            <span class="arrow-icon" :class="{ rotated: showMoreMenu }">â–¼</span>
                        </button>
                        
                        <!-- æ›´å¤šåŠŸèƒ½èœå• -->
                        <div v-show="showMoreMenu" class="more-menu">
                            <!-- æ—¥å¿—é…ç½®é¡µé¢å·²éšè— - ä¸å¼€æ”¾ç»™ç”¨æˆ·æ‰‹åŠ¨é…ç½®
                            <div class="menu-item" @click="navigateToPage('config')">
                                <span class="menu-icon">âš™ï¸</span>
                                <span class="menu-text">æ—¥å¿—é…ç½®</span>
                            </div>
                            -->
                            <div class="menu-item" @click="navigateToPage('sftp')">
                                <span class="menu-icon">ğŸ“</span>
                                <span class="menu-text">æ–‡ä»¶ç®¡ç†</span>
                            </div>
                            <div class="menu-item" @click="navigateToPage('terminals')">
                                <span class="menu-icon">ğŸ’»</span>
                                <span class="menu-text">åœ¨çº¿ç»ˆç«¯</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- å³ä¾§æœç´¢å’Œç»“æœåŒºåŸŸ -->
                <div class="right-panel">
                    <!-- æœç´¢åŒºåŸŸ -->
                    <div class="search-section">


                        <el-form :model="searchForm" class="search-form" :disabled="!selectedLog" @submit.prevent="executeSearch">
                            <!-- ä¸»æœç´¢æ¡†å®¹å™¨ -->
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <div class="search-input-container flex items-center gap-8" :class="{ focused: searchInputFocused }" style="flex: 1;">
                                    <input type="text" v-model="searchForm.keyword" placeholder="è¾“å…¥æœç´¢å…³é”®è¯ï¼Œç•™ç©ºåˆ™æ˜¾ç¤ºæœ€æ–°æ—¥å¿—"
                                        class="search-input" @focus="searchInputFocused = true"
                                        @blur="searchInputFocused = false" @keyup.enter="executeSearch"
                                        :disabled="!selectedLog" />

                                    <!-- æœç´¢è®¾ç½®æŒ‰é’®ç»„ -->
                                    <div class="search-buttons">
                                        <!-- æœç´¢æ¨¡å¼åˆ‡æ¢ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.search_mode === 'context' }"
                                            @click="toggleSearchMode" :disabled="!selectedLog" title="æœç´¢æ¨¡å¼">
                                            <span v-if="searchForm.search_mode === 'keyword'">âš¡</span>
                                            <span v-else>ğŸ“„</span>
                                        </button>

                                        <!-- æ­£åˆ™è¡¨è¾¾å¼ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.use_regex }"
                                            @click="searchForm.use_regex = !searchForm.use_regex" :disabled="!selectedLog"
                                            title="æ­£åˆ™è¡¨è¾¾å¼">
                                            .*
                                        </button>

                                        <!-- é€†åºæœç´¢ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.reverse_order }"
                                            @click="searchForm.reverse_order = !searchForm.reverse_order"
                                            :disabled="!selectedLog" title="é€†åºæœç´¢">
                                            <span v-if="searchForm.reverse_order">â¬†ï¸</span>
                                            <span v-else>â¬‡ï¸</span>
                                        </button>

                                        <!-- æŒ‡å®šæ–‡ä»¶æœç´¢ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.use_file_filter }" @click="toggleFileFilter"
                                            :disabled="!selectedLog" title="æŒ‡å®šæ–‡ä»¶æœç´¢">
                                            ğŸ“
                                        </button>

                                        <!-- ä¸Šä¸‹æ–‡è¡Œæ•° - åªåœ¨ä¸Šä¸‹æ–‡æ¨¡å¼æ—¶æ˜¾ç¤º -->
                                        <template v-if="searchForm.search_mode === 'context'">
                                            <span class="text-12 text-muted" style="margin-left: 8px;">è¡Œæ•°:</span>
                                            <input type="number" v-model.number="searchForm.context_span"
                                                class="context-span-input" min="0" max="20" :disabled="!selectedLog"
                                                title="ä¸Šä¸‹æ–‡è¡Œæ•°" />
                                        </template>
                                    </div>
                                </div>
                                
                                <!-- æœç´¢æŒ‰é’® - ç§»åˆ°å¤–é¢ -->
                                <button type="button" class="execute-search-btn" @click="executeSearch">
                                    æœç´¢
                                </button>
                            </div>

                            <!-- æ–‡ä»¶è¿‡æ»¤å™¨ (å¸¦è¿‡æ¸¡) -->
                            <transition name="file-filter" @after-enter="updateResultsHeight" @after-leave="updateResultsHeight">
                                <div v-if="searchForm.use_file_filter" style="margin-top:12px;">
                                    <div style="display:flex; gap:16px; flex-wrap:wrap;">
                                        <div v-for="group in groupedFiles" :key="group.key" style="flex:1; min-width:380px; display:flex; flex-direction:column; gap:6px;">
                                            <div style="display:flex; align-items:center; gap:10px;">
                                                <span style="font-size:13px; font-weight:600; color:#409eff; white-space:nowrap;">[[ group.host ]]</span>
                                                <div class="selected-file-box" :class="{ empty: !searchForm.selected_files[group.key] }">
                                                    <template v-if="searchForm.selected_files[group.key]">
                                                        <span style="word-break:break-all;">[[ formatDisplayPath(searchForm.selected_files[group.key]) ]]</span>
                                                        <span class="clear-icon" @click.stop="clearSelectedFile(group)" style="position:absolute; right:30px; top:50%; transform:translateY(-50%); cursor:pointer; font-size:14px; color:#b1b3b8; line-height:1; padding:2px;" title="æ¸…é™¤">Ã—</span>
                                                    </template>
                                                    <template v-else>
                                                        <span style="color:#909399;">æœªé€‰æ‹©æ–‡ä»¶</span>
                                                    </template>
                                                </div>
                                                <el-button size="small" type="primary" plain style="white-space:nowrap; height:34px; padding:0 14px; display:flex; align-items:center; border-radius:6px;" @click="openSftpBrowser(group)" :disabled="!selectedLog || browsing.loading[group.originalHost]">
                                                    æµè§ˆ
                                                </el-button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </transition>
                            <!-- SFTP æµè§ˆå¯¹è¯æ¡† -->
                            <el-dialog v-model="browsing.visible" title="è¿œç¨‹æ–‡ä»¶æµè§ˆ" width="720px" :close-on-click-modal="false" @close="closeBrowser">
                                <div v-if="browsing.currentHost" style="margin-bottom:8px; font-size:13px; color:#606266; display:flex; flex-wrap:wrap; gap:12px; align-items:center;">
                                    <span>ä¸»æœº: <strong>[[ browsing.currentHost ]]</strong></span>
                                    <span>è·¯å¾„: <code style="font-size:12px; background:#f4f4f5; padding:2px 6px; border-radius:4px;">[[ browsing.currentPath || '/' ]]</code></span>
                                    <el-button size="small" @click="refreshCurrent" :loading="isBrowsingLoading">åˆ·æ–°</el-button>
                                </div>
                                <el-skeleton v-if="isBrowsingLoading" :rows="4" animated></el-skeleton>
                                <div v-else style="max-height:360px; overflow:auto; border:1px solid #ebeef5; border-radius:6px;">
                                    <el-table :key="browsing.currentPath + '_' + browsing.items.length" :data="browsing.items" size="small" @row-dblclick="handleBrowserDblClick" style="width:100%;" height="300" :row-key="row => row.name + '_' + row.type">
                                        <el-table-column label="åç§°" prop="name">
                                            <template #default="scope">
                                                <span v-if="scope.row.is_directory">ğŸ“ [[ scope.row.name ]]</span>
                                                <span v-else>ğŸ“„ [[ scope.row.name ]]</span>
                                            </template>
                                        </el-table-column>
                                        <el-table-column label="ç±»å‹" width="70" prop="type" />
                                        <el-table-column label="å¤§å°" width="100">
                                            <template #default="scope">[[ scope.row.size_human ]]</template>
                                        </el-table-column>
                                        <el-table-column label="ä¿®æ”¹æ—¶é—´" width="180">
                                            <template #default="scope">[[ formatFileTime(scope.row.modified_time) ]]</template>
                                        </el-table-column>
                                    </el-table>
                                    <div v-if="!browsing.items.length" style="padding:12px; text-align:center; color:#909399; font-size:13px;">ç›®å½•ä¸ºç©ºæˆ–æ— æƒé™</div>
                                    <div v-else style="padding:4px 8px; font-size:12px; color:#606266;">å…± [[ browsing.items.length ]] é¡¹</div>
                                </div>
                                <template #footer>
                                    <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                                        <div>
                                            <el-button size="small" @click="goParent" :disabled="!browsing.parentPath">ä¸Šçº§ç›®å½•</el-button>
                                        </div>
                                        <div>
                                            <el-button size="small" @click="closeBrowser">å…³é—­</el-button>
                                        </div>
                                    </div>
                                </template>
                            </el-dialog>
                        </el-form>
                    </div>

                    <!-- æ—¥å¿—ç»“æœæ ‡ç­¾æ  -->
                    <div class="log-tabs-bar" v-if="tabs.length">
                    <div v-for="tab in tabs" :key="tab.id" @click="activateTab(tab.id)"
                        :class="['log-tab-item', { active: tab.id === activeTabId }]">
                            <span class="tab-title" :title="tab.title">[[ tab.title ]]</span>
                            <span v-if="tab.searching" class="tab-badge spinning" title="æœç´¢ä¸­">Â·Â·</span>
                            <span v-else-if="tab.hasSearched && tab.searchResults" class="tab-badge" :title="'åŒ¹é…: '+(tab.searchResults.total_matches||0)">[[ tab.searchResults.total_matches ]]</span>
                            <span class="close" @click.stop="closeTab(tab.id)" title="å…³é—­">Ã—</span>
                        </div>
                    </div>

                    <!-- æœç´¢ç»“æœåŒºåŸŸ -->
                    <div class="results-section" ref="resultsWrapper">

                        <!-- ä½¿ç”¨æ—¥å¿—æœç´¢ç»“æœç»„ä»¶ï¼ˆä»…åœ¨æœç´¢å®Œæˆåè¿›è¡Œé«˜äº®ï¼‰ -->
                        <log-search-results
                            :key="activeTab ? activeTab.resultsVersion : resultsVersion"
                            :search-results="activeTab ? activeTab.searchResults : searchResults"
                            :search-keyword="activeTab ? activeTab.highlightKeyword : highlightKeyword"
                            :use-regex="searchForm.use_regex"
                            :height="searchResultsHeight"
                            :max-results="5000"
                            :show-search-stats="false"
                            :show-host-grouping="true"
                            :enabled-highlighters="effectiveHighlighters"
                            empty-message="æœªæ‰¾åˆ°åŒ¹é…çš„æ—¥å¿—è®°å½•"
                        />
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;
        const { ElMessage, ElMessageBox, ElLoading } = ElementPlus;

    const app = createApp({
            components: {
                LogSearchResults
            },
            data() {
                return {
                    logs: [],
                    selectedLog: null,
                    logsLoading: false,
                    searching: false,
                    hasSearched: false,
                    resultsVersion: 0, // æ¯æ¬¡æœç´¢é€’å¢ä»¥é‡å»ºç»“æœç»„ä»¶ï¼Œé‡Šæ”¾å†…å­˜
                    highlightKeyword: '', // ä»…åœ¨æœç´¢å®Œæˆåç”¨äºé«˜äº®çš„å…³é”®è¯
                    searchInputFocused: false,
                    availableFiles: [], // å¯ç”¨æ–‡ä»¶åˆ—è¡¨ (åŸºäºæ—¥å¿—é…ç½®è¿”å›)
                    browsing: {
                        visible: false,
                        currentHost: '',
                        currentHostIndex: -1,
                        currentPath: '',
                        parentPath: null,
                        items: [],
                        connectionIds: {}, // host -> connection_id
                        loading: {}
                    },
                    filesLoading: false, // æ–‡ä»¶åˆ—è¡¨åŠ è½½çŠ¶æ€
                    collapsedGroups: new Set(), // æŠ˜å çš„åˆ†ç»„
                    showMoreMenu: false, // æ›´å¤šèœå•æ˜¾ç¤ºçŠ¶æ€
                    dynamicResultsHeight: '400px', // åŠ¨æ€ç»“æœé«˜åº¦
                    searchForm: {
                        keyword: '',
                        search_mode: 'context', // keyword æˆ– context
                        context_span: 5,
                        use_regex: false,
                        reverse_order: false,
                        use_file_filter: false,
                        selected_file: '',  // ä¿æŒå‘åå…¼å®¹
                        selected_files: {},  // æ–°å¢ï¼šä¸»æœºåˆ°æ–‡ä»¶çš„æ˜ å°„
                        max_lines: 2000 // æ¯æ¬¡æœç´¢çš„æœ€å¤§è¡Œæ•°
                    },
                    searchResults: null,
                    // å¤šæ ‡ç­¾ç®¡ç†
                    tabs: [],
                    activeTabId: null,
                    nextTabSeq: 1
                };
            },

            computed: {
                // æŒ‰åˆ†ç»„ç»„ç»‡çš„æ—¥å¿—åˆ—è¡¨
                groupedLogs() {
                    const groups = {};
                    this.logs.forEach(log => {
                        const groupName = log.group || 'é»˜è®¤åˆ†ç»„';
                        if (!groups[groupName]) {
                            groups[groupName] = [];
                        }
                        groups[groupName].push(log);
                    });

                    return Object.keys(groups).map(groupName => ({
                        name: groupName,
                        logs: groups[groupName].sort((a, b) => a.name.localeCompare(b.name)),
                        isCollapsed: this.collapsedGroups.has(groupName)
                    })).sort((a, b) => {
                        // é»˜è®¤åˆ†ç»„æ’åœ¨æœ€å
                        if (a.name === 'é»˜è®¤åˆ†ç»„' && b.name !== 'é»˜è®¤åˆ†ç»„') return 1;
                        if (b.name === 'é»˜è®¤åˆ†ç»„' && a.name !== 'é»˜è®¤åˆ†ç»„') return -1;
                        return a.name.localeCompare(b.name);
                    });
                },
                
                // æŒ‰ä¸»æœº(å«é‡å¤IP)åˆ†ç»„çš„æ–‡ä»¶åˆ—è¡¨ï¼ŒåŒºåˆ†åŒä¸€IPçš„å¤šä¸ª SSH é…ç½®
                groupedFiles() {
                    if (!this.selectedLog || !this.selectedLog.sshs || !this.selectedLog.sshs.length) {
                        return [];
                    }
                    const sshs = this.selectedLog.sshs;
                    const hostCount = {};
                    sshs.forEach(s => { const h = s.host || 'unknown'; hostCount[h] = (hostCount[h] || 0) + 1; });
                    const groups = [];
                    sshs.forEach((s, idx) => {
                        const host = s.host || 'unknown';
                        const displayHost = hostCount[host] > 1 ? `${host}#${idx + 1}` : host;
                        const key = `${host}|${idx}`; // ä¼ ç»™åç«¯çš„å”¯ä¸€é”®
                        let files = [];
                        // è‹¥å½“å‰æµè§ˆçª—å£æŒ‡å‘è¯¥ ssh indexï¼Œåˆå¹¶æµè§ˆç›®å½•ä¸­çš„æ–‡ä»¶ï¼ˆéç›®å½•ï¼‰
                        if (this.browsing.currentHost === host && this.browsing.currentHostIndex === idx && this.browsing.items.length) {
                            const fileItems = this.browsing.items.filter(i => !i.is_directory).map(i => ({
                                host,
                                filename: i.name,
                                full_path: (this.browsing.currentPath === '/' ? '/' : this.browsing.currentPath + '/') + i.name
                            }));
                            const existing = new Set(files.map(f => f.full_path));
                            fileItems.forEach(f => { if (!existing.has(f.full_path)) files.push(f); });
                        }
                        files.sort((a, b) => a.filename.localeCompare(b.filename));
                        groups.push({ key, host: displayHost, originalHost: host, sshIndex: idx, files });
                    });
                    return groups;
                },
                isBrowsingLoading() {
                    if (!this.browsing || !this.browsing.currentHost) return false;
                    return !!this.browsing.loading[this.browsing.currentHost];
                },

                // å½“å‰æ¿€æ´»æ ‡ç­¾
                activeTab() { return this.tabs.find(t => t.id === this.activeTabId) || null; },

                // é«˜äº®å™¨å¼€å…³ï¼šä»…åœ¨æœç´¢å®Œæˆåå¯ç”¨ï¼ˆæŒ‰å½“å‰æ ‡ç­¾ï¼‰
                effectiveHighlighters() {
                    const tab = this.activeTab;
                    if (!tab || !tab.hasSearched || tab.searching || !tab.searchResults) {
                        return {
                            logLevels: false,
                            timestamps: false,
                            network: false,
                            xml: false,
                            sql: false,
                            json: false,
                            filePaths: false,
                            urls: false,
                            emails: false,
                            uuids: false
                        };
                    }
                    return {
                        logLevels: true,
                        timestamps: true,
                        network: true,
                        xml: true,
                        sql: true,
                        json: true,
                        filePaths: true,
                        urls: true,
                        emails: true,
                        uuids: true
                    };
                },

                // ç»“æœé«˜åº¦ç”±æµ‹é‡é©±åŠ¨
                searchResultsHeight() { return this.dynamicResultsHeight; },

                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¿…éœ€çš„æ–‡ä»¶éƒ½å·²é€‰æ‹©
                isFileFilterValid() {
                    // ä¸å†è‡ªåŠ¨åŠ è½½æ–‡ä»¶åˆ—è¡¨ï¼Œæ”¹ä¸ºçº¯ SFTP æµè§ˆé€‰æ‹©

                    // æ£€æŸ¥æ¯ä¸ªä¸»æœºæ˜¯å¦éƒ½é€‰æ‹©äº†æ–‡ä»¶
                    return this.groupedFiles.every(group =>
                        this.searchForm.selected_files[group.host]
                    );
                }
            },

            mounted() {
                this.loadLogs();

                // æ·»åŠ å…¨å±€å›è½¦é”®ç›‘å¬
                document.addEventListener('keydown', this.handleGlobalKeydown);
                
                // æ·»åŠ ç‚¹å‡»å¤–éƒ¨å…³é—­èœå•çš„ç›‘å¬
                document.addEventListener('click', this.handleClickOutside);

                // åˆæ¬¡è®¡ç®—é«˜åº¦
                this.$nextTick(() => this.updateResultsHeight());
                window.addEventListener('resize', this.updateResultsHeight, { passive: true });

                // å¦‚æœé€šè¿‡ç‹¬ç«‹é¡µé¢è¿›å…¥ (sftp / terminals / config)
                if (window.APP_PAGE && ['sftp','terminals','config'].includes(window.APP_PAGE)) {
                    // å»¶è¿Ÿè®©ç»„ä»¶åˆå§‹åŒ–å®Œæˆ
                    setTimeout(()=>{ this.navigateToPage(window.APP_PAGE); }, 300);
                }
            },

            beforeUnmount() {
                // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
                document.removeEventListener('keydown', this.handleGlobalKeydown);
                document.removeEventListener('click', this.handleClickOutside);
                window.removeEventListener('resize', this.updateResultsHeight);
            },

            methods: {
                // é€šç”¨é”™è¯¯å¤„ç†æ–¹æ³•
                handleApiError(error, defaultMessage = 'æ“ä½œå¤±è´¥') {
                    const errorInfo = error.response?.data?.error || error.error || {};
                    let errorMessage = defaultMessage;
                    
                    // æ ¹æ®é”™è¯¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„æ¶ˆæ¯
                    switch (errorInfo.code) {
                        case 'VALIDATION_ERROR':
                            errorMessage = `å‚æ•°é”™è¯¯: ${errorInfo.message}`;
                            break;
                        case 'INVALID_CONTEXT_SPAN':
                            errorMessage = 'ä¸Šä¸‹æ–‡è¡Œæ•°è®¾ç½®æ— æ•ˆï¼Œè¯·è®¾ç½®ä¸º0-50ä¹‹é—´çš„æ•´æ•°';
                            break;
                        case 'INVALID_SEARCH_MODE':
                            errorMessage = 'æœç´¢æ¨¡å¼æ— æ•ˆï¼Œè¯·é€‰æ‹©æ­£ç¡®çš„æœç´¢æ–¹å¼';
                            break;
                        case 'INVALID_FILE_FILTER':
                            errorMessage = 'æ–‡ä»¶è¿‡æ»¤è®¾ç½®æ— æ•ˆï¼Œå¯ç”¨è¿‡æ»¤æ—¶è¯·æŒ‡å®šè¦æœç´¢çš„æ–‡ä»¶';
                            break;
                        case 'CONNECTION_ERROR':
                            errorMessage = `è¿æ¥å¤±è´¥: ${errorInfo.message || 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'}`;
                            break;
                        case 'DEADLINE_EXCEEDED':
                            errorMessage = `æ“ä½œè¶…æ—¶: ${errorInfo.message || 'è¯·ç¨åé‡è¯•'}`;
                            break;
                        case 'NOT_FOUND':
                            // é’ˆå¯¹ä¸åŒåœºæ™¯æä¾›æ›´å…·ä½“çš„é”™è¯¯æ¶ˆæ¯
                            if (defaultMessage.includes('æ—¥å¿—')) {
                                errorMessage = 'æ—¥å¿—é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆé…ç½®æ—¥å¿—';
                            } else {
                                errorMessage = errorInfo.message || 'èµ„æºä¸å­˜åœ¨';
                            }
                            break;
                        case 'PERMISSION_DENIED':
                            // é’ˆå¯¹ä¸åŒåœºæ™¯æä¾›æ›´å…·ä½“çš„é”™è¯¯æ¶ˆæ¯
                            if (defaultMessage.includes('æ—¥å¿—')) {
                                errorMessage = 'æƒé™ä¸è¶³ï¼Œæ— æ³•è®¿é—®æ—¥å¿—é…ç½®';
                            } else if (defaultMessage.includes('æ–‡ä»¶')) {
                                errorMessage = 'æƒé™ä¸è¶³ï¼Œæ— æ³•è®¿é—®æ–‡ä»¶åˆ—è¡¨';
                            } else {
                                errorMessage = `æƒé™ä¸è¶³: ${errorInfo.message || 'è¯·è”ç³»ç®¡ç†å‘˜'}`;
                            }
                            break;
                        case 'INTERNAL':
                            errorMessage = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
                            break;
                        default:
                            errorMessage = errorInfo.message || defaultMessage;
                    }
                    
                    ElMessage.error(errorMessage);
                    
                    // å¦‚æœæ˜¯è°ƒè¯•æ¨¡å¼ï¼Œæ‰“å°è¯¦ç»†é”™è¯¯ä¿¡æ¯
                    if (errorInfo.details) {
                        console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', errorInfo.details);
                    }
                },
                // æ‰§è¡Œæœç´¢
                async executeSearch() {
                    const tab = this.activeTab;
                    if (!tab || !this.selectedLog) {
                        ElMessage.warning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ—¥å¿—é…ç½®');
                        return;
                    }
                    if (this.searchForm.use_file_filter) {
                        const totalHosts = this.groupedFiles.length;
                        const chosen = Object.keys(this.searchForm.selected_files || {}).length;
                        if (chosen === 0) {
                            ElMessage.info('æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶ï¼Œå°†ä½¿ç”¨é…ç½®é»˜è®¤è·¯å¾„');
                        } else if (chosen < totalHosts) {
                            ElMessage.info(`éƒ¨åˆ†ä¸»æœºæœªé€‰æ–‡ä»¶ï¼ˆ${chosen}/${totalHosts}ï¼‰ï¼Œæœªé€‰çš„å°†ç”¨é»˜è®¤è·¯å¾„`);
                        }
                    }
                    this.buildPlaceholderResults(tab);
                    tab.highlightKeyword='';
                    await this.$nextTick();
                    tab.searching = true;
                    tab.hasSearched = true;
                    try {
                        const response = await axios.post(`/api/v1/logs/${this.selectedLog.name}/search`, this.searchForm);
                        if (response.data.success) {
                            tab.searchResults = response.data.data;
                            if (tab.searchResults) tab.searchResults.pre_search = false;
                            tab.highlightKeyword = this.searchForm.keyword || '';
                            tab.resultsVersion += 1;
                            if (tab.searchResults.total_matches === 0) {
                                ElMessage.info('æœªæ‰¾åˆ°åŒ¹é…çš„æ—¥å¿—è®°å½•');
                            } else {
                                ElMessage.success(`æ‰¾åˆ° ${tab.searchResults.total_matches} ä¸ªåŒ¹é…é¡¹`);
                            }
                        } else {
                            this.handleApiError({ response: { data: response.data } }, 'æœç´¢å¤±è´¥');
                            tab.searchResults = null;
                            tab.highlightKeyword='';
                        }
                    } catch (e) {
                        this.handleApiError(e, 'æœç´¢è¯·æ±‚å¤±è´¥');
                        console.error('æœç´¢å¤±è´¥:', e);
                        tab.searchResults=null;
                        tab.highlightKeyword='';
                    } finally {
                        tab.searching = false;
                        this.$nextTick(()=>this.updateResultsHeight());
                    }
                },
                // æ„å»ºå ä½ç»“æœ
                buildPlaceholderResults(tab=null) {
                    tab = tab || this.activeTab;
                    if (!tab) return;
                    const logRef = tab.selectedLog || this.selectedLog;
                    if (!logRef || !logRef.sshs || !logRef.sshs.length) {
                        tab.searchResults = null;
                        tab.resultsVersion += 1;
                        if (tab.id === this.activeTabId) { this.searchResults=null; this.resultsVersion=tab.resultsVersion; }
                        return;
                    }
                    const hosts = logRef.sshs.map((s,idx)=>({
                        host: s.host || 'unknown',
                        ssh_index: idx,
                        results: [],
                        total_results: 0,
                        search_time: 0,
                        search_result:{ content:'', file_path:'', keyword:'', total_lines:0, search_time:0, matches:[] },
                        success: true
                    }));
                    tab.searchResults = {
                        log_name: logRef.name,
                        keyword: '',
                        search_params: {},
                        total_hosts: hosts.length,
                        hosts,
                        total_results: 0,
                        total_matches: 0,
                        total_search_time: 0,
                        parallel_execution: false,
                        pre_search: true
                    };
                    tab.resultsVersion += 1;
                    if (tab.id === this.activeTabId) {
                        this.searchResults = tab.searchResults;
                        this.resultsVersion = tab.resultsVersion;
                    }
                },

                // å…¨å±€é”®ç›˜äº‹ä»¶å¤„ç†
                handleGlobalKeydown(event) {
                    // æŒ‰ä¸‹å›è½¦é”®ä¸”ä¸åœ¨è¾“å…¥æ¡†ã€æ–‡æœ¬åŸŸæˆ–å…¶ä»–å¯ç¼–è¾‘å…ƒç´ ä¸­
                    if (event.key === 'Enter' &&
                        !['INPUT', 'TEXTAREA'].includes(event.target.tagName) &&
                        !event.target.isContentEditable) {

                        // é˜²æ­¢é»˜è®¤è¡Œä¸ºå’Œäº‹ä»¶å†’æ³¡
                        event.preventDefault();
                        event.stopPropagation();

                        // æ‰§è¡Œæœç´¢
                        this.executeSearch();
                    }
                    
                    // æŒ‰ESCé”®å…³é—­æ›´å¤šèœå•
                    if (event.key === 'Escape' && this.showMoreMenu) {
                        this.showMoreMenu = false;
                    }
                },

                // ç‚¹å‡»å¤–éƒ¨å…³é—­èœå•
                handleClickOutside(event) {
                    // æ£€æŸ¥ç‚¹å‡»æ˜¯å¦åœ¨æ›´å¤šæŒ‰é’®åŒºåŸŸå¤–
                    const moreActions = event.target.closest('.more-actions');
                    if (!moreActions && this.showMoreMenu) {
                        this.showMoreMenu = false;
                    }
                },

                // åˆ†ç»„æŠ˜å /å±•å¼€æ§åˆ¶
                toggleGroup(groupName) {
                    if (this.collapsedGroups.has(groupName)) {
                        this.collapsedGroups.delete(groupName);
                    } else {
                        this.collapsedGroups.add(groupName);
                    }
                },

                // åˆ‡æ¢æ›´å¤šèœå•æ˜¾ç¤ºçŠ¶æ€
                toggleMoreMenu() {
                    this.showMoreMenu = !this.showMoreMenu;
                },

                // é¡µé¢å¯¼èˆª
                navigateToPage(page) {
                    this.showMoreMenu = false; // å…³é—­èœå•
                    
                    // é¡µé¢é…ç½®
                    const pageConfig = {
                        'config': {
                            url: '/config',
                            title: 'æ—¥å¿—é…ç½®',
                            icon: 'âš™ï¸'
                        },
                        'sftp': {
                            url: '/sftp',
                            title: 'æ–‡ä»¶ç®¡ç†',
                            icon: 'ğŸ“'
                        },
                        'terminals': {
                            url: '/terminals',
                            title: 'åœ¨çº¿ç»ˆç«¯',
                            icon: 'ğŸ’»'
                        }
                    };
                    
                    const config = pageConfig[page];
                    if (config) {
                        // æ˜¾ç¤ºå¯¼èˆªæç¤º
                        ElMessage.info(`æ­£åœ¨æ‰“å¼€ ${config.icon} ${config.title}...`);
                        
                        // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´å†æ‰“å¼€ï¼Œè®©ç”¨æˆ·çœ‹åˆ°æç¤º
                        setTimeout(() => {
                            // å¯ä»¥é€‰æ‹©åœ¨æ–°çª—å£æ‰“å¼€æˆ–å½“å‰çª—å£è·³è½¬
                            // æ–°çª—å£æ‰“å¼€ï¼ˆæ¨èï¼‰
                            window.open(config.url, '_blank');
                            
                            // å¦‚æœè¦åœ¨å½“å‰çª—å£è·³è½¬ï¼Œä½¿ç”¨ï¼š
                            // window.location.href = config.url;
                        }, 300);
                    } else {
                        ElMessage.warning(`åŠŸèƒ½ ${page} æš‚æœªå¼€æ”¾`);
                    }
                },

                async loadLogs() {
                    this.logsLoading = true;
                    try {
                        const response = await axios.get('/api/v1/logs');
                        if (response.data.success) {
                            this.logs = response.data.data.logs || [];
                            // é»˜è®¤æŠ˜å æ‰€æœ‰åˆ†ç»„
                            this.collapsedGroups.clear();
                            const groups = new Set();
                            this.logs.forEach(log => {
                                const groupName = log.group || 'é»˜è®¤åˆ†ç»„';
                                groups.add(groupName);
                            });
                            groups.forEach(groupName => {
                                this.collapsedGroups.add(groupName);
                            });
                        } else {
                            this.handleApiError({ response: { data: response.data } }, 'åŠ è½½æ—¥å¿—åˆ—è¡¨å¤±è´¥');
                        }
                    } catch (error) {
                        this.handleApiError(error, 'è¿æ¥æœåŠ¡å™¨å¤±è´¥');
                        console.error('åŠ è½½æ—¥å¿—å¤±è´¥:', error);
                    } finally {
                        this.logsLoading = false;
                    }
                },

                selectLog(log) {
                    if (!log) return;
                    // è‹¥å·²æœ‰å¯¹åº”æ ‡ç­¾åˆ™æ¿€æ´»
                    const exist = this.tabs.find(t => t.logName === log.name);
                    if (exist) { this.activateTab(exist.id); return; }
                    // åˆ›å»ºæ–°æ ‡ç­¾
                    const tab = this._createTabForLog(log);
                    this.tabs.push(tab);
                    this.activeTabId = tab.id;
                    this._syncActiveTabToRoot();
                    // æ„å»ºå ä½ & æ‹‰å–è¯¦æƒ…
                    this.buildPlaceholderResults(tab);
                    this.ensureLogDetail(log).then(()=>{
                        if (tab.searchResults && tab.searchResults.pre_search) {
                            this.buildPlaceholderResults(tab); // æ›´æ–° sshs
                        }
                    });
                },

                // ç¡®ä¿ selectedLog æ‹¥æœ‰ sshsï¼ˆä¸åç«¯ detail æ¥å£å­—æ®µ ssh_configs å¯¹é½ï¼‰
                async ensureLogDetail(log) {
                    if (!log || log.sshs || !log.name) return;
                    try {
                        const resp = await axios.get(`/api/v1/logs/${log.name}`);
                        if (resp.data.success && resp.data.data) {
                            const detail = resp.data.data;
                            // åç«¯è¿”å› ssh_configsï¼›å‰ç«¯ç»Ÿä¸€ä½¿ç”¨ sshs
                            const sshs = detail.ssh_configs || [];
                            // å°† sshs æŒ‚åˆ°åŸ log å¯¹è±¡ä¸Šï¼Œä¿æŒå¼•ç”¨ä¸€è‡´
                            log.sshs = sshs; // Vue3 ç›´æ¥èµ‹å€¼å³å¯è§¦å‘å“åº”
                            // å¦‚æœå½“å‰ selectedLog æŒ‡å‘è¯¥å¯¹è±¡ï¼Œç¡®ä¿å±æ€§å¯ç”¨
                            if (this.selectedLog === log) {
                                this.selectedLog.sshs = sshs;
                                if (!this.hasSearched) {
                                    this.buildPlaceholderResults();
                                }
                            }
                        }
                    } catch (e) {
                        // é™é»˜å¤±è´¥ï¼Œåªåœ¨ç”¨æˆ·çœŸæ­£éœ€è¦æ—¶å†æç¤º
                        console.warn('è·å–æ—¥å¿—è¯¦ç»†é…ç½®å¤±è´¥', e);
                    }
                },

                // åˆ‡æ¢æœç´¢æ¨¡å¼
                toggleSearchMode() {
                    this.searchForm.search_mode = this.searchForm.search_mode === 'keyword' ? 'context' : 'keyword';
                    const mode = this.searchForm.search_mode === 'keyword' ? 'å…³é”®è¯æœç´¢' : 'ä¸Šä¸‹æ–‡æœç´¢';
                    ElMessage.info(`å·²åˆ‡æ¢åˆ°${mode}æ¨¡å¼`);
                },

                // åˆ‡æ¢æ–‡ä»¶è¿‡æ»¤
                toggleFileFilter() {
                    this.searchForm.use_file_filter = !this.searchForm.use_file_filter;
                    if (this.searchForm.use_file_filter) {
                        ElMessage.info('å·²å¯ç”¨æ–‡ä»¶è¿‡æ»¤ï¼Œå¯é€šè¿‡â€œæµè§ˆâ€é€‰æ‹©æ–‡ä»¶');
                    } else {
                        this.searchForm.selected_file = '';
                        this.searchForm.selected_files = {};
                        this.availableFiles = [];
                        ElMessage.info('å·²å…³é—­æ–‡ä»¶è¿‡æ»¤');
                    }
                    this.$nextTick(() => this.updateResultsHeight());
                },

                // åŠ è½½å¯ç”¨æ–‡ä»¶åˆ—è¡¨
                // ï¼ˆåºŸå¼ƒï¼‰loadAvailableFiles å·²ç§»é™¤ï¼Œæ–‡ä»¶æ¥æºç»Ÿä¸€é€šè¿‡ SFTP æµè§ˆå™¨

                // æ‰“å¼€æµè§ˆå™¨ï¼ˆæ”¯æŒåŒIPå¤šå®ä¾‹ï¼Œå‚æ•°ä¸ºåˆ†ç»„å¯¹è±¡æˆ–åŸ host å­—ç¬¦ä¸²ï¼‰
                async openSftpBrowser(groupOrHost) {
                    if (!this.selectedLog) {
                        ElMessage.error('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ—¥å¿—é…ç½®');
                        return;
                    }
                    // è‹¥è¿˜æ²¡æœ‰ sshsï¼Œå°è¯•åŠ è½½ä¸€æ¬¡
                    if (!this.selectedLog.sshs) {
                        await this.ensureLogDetail(this.selectedLog);
                    }
                    if (!this.selectedLog.sshs) {
                        ElMessage.error('å½“å‰æ—¥å¿—é…ç½®ç¼ºå°‘ SSH ä¿¡æ¯');
                        return;
                    }
                    let sshIndex, host;
                    if (typeof groupOrHost === 'string') {
                        host = groupOrHost;
                        sshIndex = this.selectedLog.sshs.findIndex(s => s.host === host);
                    } else {
                        host = groupOrHost.originalHost;
                        sshIndex = groupOrHost.sshIndex;
                    }
                    if (sshIndex == null || sshIndex < 0 || sshIndex >= this.selectedLog.sshs.length) {
                        ElMessage.error('æœªæ‰¾åˆ°å¯¹åº”ä¸»æœº SSH é…ç½®');
                        return;
                    }
                    this.browsing.currentHost = host;
                    this.browsing.currentHostIndex = sshIndex;
                    this.browsing.visible = true;
                    await this.ensureSftpConnection(host, sshIndex);
                    // è®¡ç®—åˆå§‹ç›®å½• = ssh é…ç½®ä¸­çš„ pathï¼ˆå»æ‰æ–‡ä»¶åæˆ–å ä½ç¬¦éƒ¨åˆ†ï¼‰
                    try {
                        const sshCfg = this.selectedLog.sshs[sshIndex] || {};
                        let rawPath = sshCfg.path || this.selectedLog.path || '/';
                        if (!rawPath) rawPath = '/';
                        // å¦‚æœåŒ…å«å ä½ç¬¦ï¼Œæˆªå–åˆ°å ä½ç¬¦å‰
                        const phIdx = rawPath.search(/\{[A-Z]+\}/);
                        if (phIdx !== -1) {
                            rawPath = rawPath.slice(0, phIdx);
                        }
                        // è‹¥ä¸æ˜¯ä»¥ / ç»“å°¾ï¼Œè§†ä¸ºæ–‡ä»¶ï¼Œå–å…¶æ‰€åœ¨ç›®å½•
                        if (!rawPath.endsWith('/')) {
                            rawPath = rawPath.slice(0, rawPath.lastIndexOf('/')) + '/';
                        }
                        this.browsing.currentPath = rawPath;
                        this.refreshCurrent();
                    } catch (e) {
                        console.error('è®¡ç®—åˆå§‹ç›®å½•å¤±è´¥', e);
                    }
                },

                // åˆ·æ–°å½“å‰æµè§ˆç›®å½•
                async refreshCurrent() {
                    if (!this.selectedLog) return;
                    const { currentHost, currentHostIndex, currentPath } = this.browsing;
                    if (!currentHost || currentHostIndex == null || currentHostIndex < 0) return;
                    if (!currentPath) {
                        this.listRemotePath(currentHost, '/');
                    } else {
                        this.listRemotePath(currentHost, currentPath);
                    }
                },

                async ensureSftpConnection(host, sshIndex) {
                    if (this.browsing.connectionIds[host]) return;
                    this.browsing.loading[host] = true;
                    try {
                        const resp = await axios.post('/api/v1/sftp/connect-by-config', { log_name: this.selectedLog.name, ssh_index: sshIndex });
                        if (resp.data.success) {
                            this.browsing.connectionIds[host] = resp.data.data.connection_id;
                        } else {
                            this.handleApiError({ response: { data: resp.data } }, 'SFTPè¿æ¥å¤±è´¥');
                        }
                    } catch (e) {
                        this.handleApiError(e, 'SFTPè¿æ¥è¯·æ±‚å¤±è´¥');
                    } finally {
                        this.browsing.loading[host] = false;
                    }
                },

                async listRemotePath(host, path) {
                    const cid = this.browsing.connectionIds[host];
                    if (!cid) return;
                    this.browsing.loading[host] = true;
                    try {
                        const resp = await axios.post('/api/v1/sftp/list', { connection_id: cid, path });
                        if (resp.data.success) {
                            const data = resp.data.data;
                            this.browsing.currentPath = data.current_path;
                            this.browsing.parentPath = data.parent_path;
                            this.browsing.items = data.items || [];
                        } else {
                            this.handleApiError({ response: { data: resp.data } }, 'åˆ—å‡ºç›®å½•å¤±è´¥');
                        }
                    } catch (e) {
                        this.handleApiError(e, 'åˆ—å‡ºç›®å½•è¯·æ±‚å¤±è´¥');
                    } finally {
                        this.browsing.loading[host] = false;
                    }
                },

                handleBrowserDblClick(row) {
                    if (!row) return;
                    if (row.is_directory) {
                        const p = (this.browsing.currentPath === '/' ? '' : this.browsing.currentPath) + '/' + row.name;
                        this.listRemotePath(this.browsing.currentHost, p);
                    } else {
                        const full = (this.browsing.currentPath === '/' ? '/' : this.browsing.currentPath + '/') + row.name;
                        const key = `${this.browsing.currentHost}|${this.browsing.currentHostIndex}`;
                        this.searchForm.selected_files[key] = full;
                        ElMessage.success('å·²é€‰æ‹©æ–‡ä»¶: ' + row.name);
                        this.closeBrowser();
                    }
                },

                goParent() {
                    if (!this.browsing.parentPath) return;
                    this.listRemotePath(this.browsing.currentHost, this.browsing.parentPath);
                },
                closeBrowser() {
                    this.browsing.visible = false;
                },
                refreshCurrentLegacy() {
                    // legacy name kept if referenced somewhere else
                    this.refreshCurrent();
                },

                formatFileTime(timeStr) {
                    if (!timeStr) return 'æœªçŸ¥';
                    try {
                        const date = new Date(timeStr);
                        return date.toLocaleString('zh-CN', {
                            year: 'numeric', month: '2-digit', day: '2-digit',
                            hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
                        });
                    } catch (e) { return timeStr; }
                },
                formatDisplayPath(p) {
                    if (!p) return '';
                    return p.length > 80 ? p.slice(0,35)+' ... '+p.slice(-35) : p;
                },
                clearSelectedFile(group) {
                    if (!group) return;
                    delete this.searchForm.selected_files[group.key];
                },
                _defaultSearchForm() {
                    return {
                        keyword: '',
                        search_mode: 'context',
                        context_span: 5,
                        use_regex: false,
                        reverse_order: false,
                        use_file_filter: false,
                        selected_file: '',
                        selected_files: {},
                        max_lines: 2000
                    };
                },
                _createTabForLog(log) {
                    return {
                        id: 'tab_' + Date.now() + '_' + Math.random().toString(36).slice(2,8),
                        logName: log.name,
                        title: log.name,
                        selectedLog: log,
                        searchForm: JSON.parse(JSON.stringify(this._defaultSearchForm())),
                        searchResults: null,
                        highlightKeyword: '',
                        hasSearched: false,
                        searching: false,
                        resultsVersion: 0
                    };
                },
                _syncActiveTabToRoot() {
                    const tab = this.activeTab;
                    if (!tab) return;
                    this.selectedLog = tab.selectedLog;
                    this.searchForm = tab.searchForm;
                    this.searchResults = tab.searchResults;
                    this.highlightKeyword = tab.highlightKeyword;
                    this.hasSearched = tab.hasSearched;
                    this.searching = tab.searching;
                    this.resultsVersion = tab.resultsVersion;
                },
                activateTab(id) {
                    if (this.activeTabId === id) return;
                    const tab = this.tabs.find(t => t.id === id);
                    if (!tab) return;
                    this.activeTabId = id;
                    this._syncActiveTabToRoot();
                    this.$nextTick(()=>this.updateResultsHeight());
                },
                closeTab(id) {
                    const idx = this.tabs.findIndex(t => t.id === id);
                    if (idx === -1) return;
                    const closingActive = this.tabs[idx].id === this.activeTabId;
                    this.tabs.splice(idx,1);
                    if (!this.tabs.length) {
                        this.selectedLog = null;
                        this.activeTabId = null;
                        this.searchForm = this._defaultSearchForm();
                        this.searchResults = null;
                        this.highlightKeyword='';
                        this.hasSearched=false;
                        this.searching=false;
                        this.resultsVersion=0;
                    } else if (closingActive) {
                        const newTab = this.tabs[Math.max(0, idx-1)];
                        this.activeTabId = newTab.id;
                        this._syncActiveTabToRoot();
                    }
                },
                updateResultsHeight() {
                    try {
                        const wrapper = this.$refs.resultsWrapper;
                        if (!wrapper) return;
                        const wrapperRect = wrapper.getBoundingClientRect();
                        const parentPanel = wrapper.closest('.right-panel');
                        let availableHeight;
                        if (parentPanel) {
                            const panelRect = parentPanel.getBoundingClientRect();
                            const bottomGap = 16;
                            const wrapperStyles = window.getComputedStyle(wrapper);
                            const paddingBottom = parseInt(wrapperStyles.paddingBottom) || 0;
                            availableHeight = panelRect.bottom - wrapperRect.top - bottomGap - paddingBottom;
                        } else {
                            const bottomGap = 16;
                            availableHeight = window.innerHeight - wrapperRect.top - bottomGap;
                        }
                        const headerEl = wrapper.querySelector('.results-section-header');
                        let headerH = 0;
                        if (headerEl) headerH = headerEl.getBoundingClientRect().height + 4;
                        availableHeight -= headerH;
                        if (availableHeight < 120) availableHeight = 120;
                        const minH = 200;
                        this.dynamicResultsHeight = Math.max(minH, availableHeight) + 'px';
                        requestAnimationFrame(()=>{
                            const w2 = this.$refs.resultsWrapper;
                            if (!w2) return;
                            const wr2 = w2.getBoundingClientRect();
                            const pp2 = w2.closest('.right-panel');
                            if (pp2) {
                                const pr2 = pp2.getBoundingClientRect();
                                const gap = 16;
                                const w2Styles = window.getComputedStyle(w2);
                                const padB2 = parseInt(w2Styles.paddingBottom) || 0;
                                let avail2 = pr2.bottom - wr2.top - gap - padB2;
                                const header2 = w2.querySelector('.results-section-header');
                                if (header2) avail2 -= header2.getBoundingClientRect().height + 4;
                                this.dynamicResultsHeight = Math.max(minH, avail2) + 'px';
                            }
                        });
                    } catch(e) {}
                }
            }
        });

        // è®¾ç½®æ’å€¼åˆ†éš”ç¬¦
        if (app.config && app.config.compilerOptions) {
            app.config.compilerOptions.delimiters = ['[[', ']]'];
        }

        app.use(ElementPlus);
        app.mount('#app');
    </script>
</body>
</html>
