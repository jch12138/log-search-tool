<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥å¿—èšåˆæœç´¢</title>
    <link rel="icon" href="/static/icons/favicon-search.svg" />

    <!-- æœ¬åœ°èµ„æº -->
    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="/static/css/element-plus.css" />
    <!-- Prism.js CSSä¸»é¢˜ -->
    <link rel="stylesheet" href="/static/css/prism-okaidia.min.css" />
    <!-- Consolidated page CSS -->
    <link rel="stylesheet" href="/static/fonts/microsoft-yahei.css" />
    <link rel="stylesheet" href="/static/css/index.css" />
    
    <!-- æœ¬åœ°JavaScriptåº“ -->
    <script src="/static/js/vendor/vue.global.js"></script>
    <script src="/static/js/vendor/element-plus.js"></script>
    <script src="/static/js/vendor/axios.min.js"></script>
    <!-- Prism.jsåº“ -->
    <script src="/static/js/vendor/prism-core.min.js"></script>
    <script src="/static/js/vendor/prism-markup.min.js"></script>
    <script src="/static/js/vendor/prism-clike.min.js"></script>
    <script src="/static/js/vendor/prism-javascript.min.js"></script>
    <script src="/static/js/vendor/prism-json.min.js"></script>
    <script src="/static/js/vendor/prism-sql.min.js"></script>
    <script src="/static/js/vendor/prism-xml-doc.min.js"></script>
    <!-- LogSearchResults ç»„ä»¶ -->
    <script src="/static/js/LogSearchResults.js"></script>

</head>

<body data-app-page="{{ page|default('') }}">
    <div id="app" class="app-root">
            <!-- ä¸»å†…å®¹åŒºåŸŸ -->
            <div class="main-content">
                <!-- å·¦ä¾§æ—¥å¿—åˆ—è¡¨ -->
                <aside class="left-panel" :class="{ 'collapsed': sidebarCollapsed && !sidebarPinned }" aria-label="æ—¥å¿—é…ç½®åˆ—è¡¨">
                    <!-- æŠ˜å çŠ¶æ€ä¸‹çš„æŒ‡ç¤ºå›¾æ ‡ï¼ˆä»…è£…é¥°ï¼Œæ‚¬åœè‡ªåŠ¨å±•å¼€ï¼‰ -->
                    <div v-if="sidebarCollapsed" class="sidebar-toggle" title="æ‚¬åœå±•å¼€">
                        ğŸ”
                    </div>
                    <div class="panel-header">
                        <h3>ğŸ” æ—¥å¿—èšåˆæœç´¢</h3>
                        <button type="button" class="pin-btn" :class="{ active: sidebarPinned }" @click.stop="toggleSidebarPin" :aria-pressed="sidebarPinned ? 'true' : 'false'" :title="sidebarPinned ? 'å–æ¶ˆå›ºå®š' : 'å›ºå®šä¾§è¾¹æ '">
                            <span aria-hidden="true">ğŸ“Œ</span>
                        </button>
                    </div>
                    <div class="log-list" v-loading="logsLoading">
                        <div v-if="logs.length === 0 && !logsLoading" class="empty-state">
                            <div>æš‚æ— æ—¥å¿—é…ç½®</div>
                        </div>
                        
                        <!-- åˆ†ç»„æ˜¾ç¤º -->
                        <div v-for="group in groupedLogs" :key="group.name" class="log-group">
                            <!-- åˆ†ç»„æ ‡é¢˜ -->
                            <button type="button" class="group-header" @click="toggleGroup(group.name)" :aria-expanded="!group.isCollapsed" :aria-controls="'group-content-' + group.name">
                                <span class="group-name">[[ group.name ]]</span>
                                <span class="group-count">([[ group.logs.length ]])</span>
                                <span class="toggle-icon" :class="{ collapsed: group.isCollapsed }" aria-hidden="true">â–¼</span>
                            </button>
                            
                            <!-- åˆ†ç»„å†…çš„æ—¥å¿—åˆ—è¡¨ -->
                            <div v-show="!group.isCollapsed" class="group-content" :id="'group-content-' + group.name">
                                <button type="button" v-for="log in group.logs" :key="log.name" class="log-item"
                                    :class="{ active: selectedLog?.name === log.name }" @click="selectLog(log)"
                                    :aria-pressed="selectedLog?.name === log.name ? 'true' : 'false'">
                                    <h4>[[ log.name ]]</h4>
                                    <p>[[ log.description || 'æš‚æ— æè¿°' ]]</p>
                                </button>
                            </div>
                        </div>
                    </div>
                    
   
                </aside>

                <!-- å³ä¾§æœç´¢å’Œç»“æœåŒºåŸŸ -->
                <main class="right-panel" aria-label="æœç´¢ä¸ç»“æœ">
                    <!-- æœç´¢åŒºåŸŸ -->
                    <div class="search-section">


                        <el-form :model="searchForm" class="search-form" :disabled="!selectedLog" @submit.prevent="executeSearch">
                            <!-- ä¸»æœç´¢æ¡†å®¹å™¨ -->
                            <div class="flex items-center gap-8">
                                <div class="search-input-container flex items-center gap-8 flex-1" :class="{ focused: searchInputFocused }">
                                    <input type="text" v-model="searchForm.keyword" placeholder="è¾“å…¥æœç´¢å…³é”®è¯ï¼Œç•™ç©ºåˆ™æ˜¾ç¤ºæœ€æ–°æ—¥å¿—"
                                        class="search-input" @focus="searchInputFocused = true" @click="searchInputFocused = true"
                                        @blur="searchInputFocused = false" @keyup.enter="executeSearch"
                                        :disabled="!selectedLog" />
                                    
                                    <!-- æœç´¢å†å² -->
                                    <div v-if="searchInputFocused && searchHistory.length > 0" class="search-history" @mousedown.prevent>
                                        <div v-for="(item, index) in searchHistory" :key="index" class="search-history-item" @click="selectHistory(item)">
                                            [[ item ]]
                                        </div>
                                    </div>

                                    <!-- æœç´¢è®¾ç½®æŒ‰é’®ç»„ -->
                                    <div class="search-buttons">
                                        <!-- æœç´¢æ¨¡å¼åˆ‡æ¢ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.search_mode === 'context' }"
                                            @click="toggleSearchMode" :disabled="!selectedLog" title="æœç´¢æ¨¡å¼">
                                            <span v-if="searchForm.search_mode === 'keyword'">âš¡</span>
                                            <span v-else>ğŸ“„</span>
                                        </button>

                                        <!-- æ­£åˆ™è¡¨è¾¾å¼ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.use_regex }"
                                            @click="searchForm.use_regex = !searchForm.use_regex" :disabled="!selectedLog"
                                            title="æ­£åˆ™è¡¨è¾¾å¼">
                                            .*
                                        </button>

                                        <!-- é€†åºæœç´¢ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.reverse_order }"
                                            @click="searchForm.reverse_order = !searchForm.reverse_order"
                                            :disabled="!selectedLog" title="é€†åºæœç´¢">
                                            <span v-if="searchForm.reverse_order">â¬†ï¸</span>
                                            <span v-else>â¬‡ï¸</span>
                                        </button>

                                        <!-- æŒ‡å®šæ–‡ä»¶æœç´¢ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.use_file_filter }" @click="toggleFileFilter"
                                            :disabled="!selectedLog" title="æŒ‡å®šæ–‡ä»¶æœç´¢">
                                            ğŸ“
                                        </button>

                                        <!-- ä¸Šä¸‹æ–‡è¡Œæ•° - åªåœ¨ä¸Šä¸‹æ–‡æ¨¡å¼æ—¶æ˜¾ç¤º -->
                                        <template v-if="searchForm.search_mode === 'context'">
                                            <span class="text-12 text-muted ml-8">è¡Œæ•°:</span>
                                            <input type="number" v-model.number="searchForm.context_span"
                                                class="context-span-input" min="0" max="20" :disabled="!selectedLog"
                                                title="ä¸Šä¸‹æ–‡è¡Œæ•°" />
                                        </template>
                                    </div>
                                </div>
                                
                                <!-- æœç´¢æŒ‰é’® - ç§»åˆ°å¤–é¢ -->
                                <button type="button" class="execute-search-btn" @click="executeSearch" :disabled="!selectedLog">
                                    æœç´¢
                                </button>
                            </div>

                            <!-- æ–‡ä»¶è¿‡æ»¤å™¨ (å¸¦è¿‡æ¸¡) -->
                            <transition name="file-filter">
                                <div v-if="searchForm.use_file_filter" class="mt-12">
                                    <div class="flex gap-16 flex-wrap">
                                        <div v-for="group in groupedFiles" :key="group.key" class="flex-1 min-w-380 flex flex-col gap-6">
                                            <div class="flex items-center gap-10">
                                                <span class="text-13 font-semibold text-primary nowrap">[[ group.host ]]</span>
                                                <div class="selected-file-box" :class="{ empty: !searchForm.selected_files[group.key] }">
                                                    <template v-if="searchForm.selected_files[group.key]">
                                                        <span class="break-all">[[ formatDisplayPath(searchForm.selected_files[group.key]) ]]</span>
                                                        <span class="clear-icon" @click.stop="clearSelectedFile(group)" title="æ¸…é™¤">Ã—</span>
                                                    </template>
                                                    <template v-else>
                                                        <span class="text-muted">æœªé€‰æ‹©æ–‡ä»¶</span>
                                                    </template>
                                                </div>
                                                <el-button size="small" type="primary" plain class="nowrap h-34 flex items-center px-14 rounded-6" @click="openSftpBrowser(group)" :disabled="!selectedLog || browsing.loading[group.originalHost]">
                                                    æµè§ˆ
                                                </el-button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </transition>
                            <!-- SFTP æµè§ˆå¯¹è¯æ¡† -->
                            <el-dialog v-model="browsing.visible" title="è¿œç¨‹æ–‡ä»¶æµè§ˆ" width="720px" :close-on-click-modal="false" @close="closeBrowser">
                                <div v-if="browsing.currentHost" class="mb-8 text-13 text-606 flex flex-wrap gap-12 items-center">
                                    <span>ä¸»æœº: <strong>[[ browsing.currentHost ]]</strong></span>
                                    <span>è·¯å¾„: <code class="code-like">[[ browsing.currentPath || '/' ]]</code></span>
                                    <el-button size="small" @click="refreshCurrent" :loading="isBrowsingLoading">åˆ·æ–°</el-button>
                                </div>
                                <el-skeleton v-if="isBrowsingLoading" :rows="4" animated></el-skeleton>
                                <div v-else class="max-h-360 overflow-auto box-border rounded-6">
                                    <el-table :key="browsing.currentPath + '_' + browsing.items.length" :data="browsing.items" size="small" @row-dblclick="handleBrowserDblClick" class="w-full" height="300" :row-key="row => row.name + '_' + row.type">
                                        <el-table-column label="åç§°" prop="name">
                                            <template #default="scope">
                                                <span v-if="scope.row.is_directory">ğŸ“ [[ scope.row.name ]]</span>
                                                <span v-else>ğŸ“„ [[ scope.row.name ]]</span>
                                            </template>
                                        </el-table-column>
                                        <el-table-column label="ç±»å‹" width="70" prop="type" />
                                        <el-table-column label="å¤§å°" width="100">
                                            <template #default="scope">[[ scope.row.size_human ]]</template>
                                        </el-table-column>
                                        <el-table-column label="ä¿®æ”¹æ—¶é—´" width="180">
                                            <template #default="scope">[[ formatDateTime(scope.row.modified_time) ]]</template>
                                        </el-table-column>
                                    </el-table>
                                    <div v-if="!browsing.items.length" class="p-12 text-center text-muted text-13">ç›®å½•ä¸ºç©ºæˆ–æ— æƒé™</div>
                                    <div v-else class="p-4 text-12 text-606">å…± [[ browsing.items.length ]] é¡¹</div>
                                </div>
                                <template #footer>
                                    <div class="flex justify-between w-full items-center">
                                        <div>
                                            <el-button size="small" @click="goParent" :disabled="!browsing.parentPath">ä¸Šçº§ç›®å½•</el-button>
                                        </div>
                                        <div>
                                            <el-button size="small" @click="closeBrowser">å…³é—­</el-button>
                                        </div>
                                    </div>
                                </template>
                            </el-dialog>
                        </el-form>
                    </div>

                    <!-- æ—¥å¿—ç»“æœæ ‡ç­¾æ  -->
                    <nav class="log-tabs-bar" v-if="tabs.length" aria-label="æœç´¢ç»“æœæ ‡ç­¾" role="tablist">
                        <div v-for="tab in tabs" :key="tab.id" @click="activateTab(tab.id)"
                            :class="['log-tab-item', { active: tab.id === activeTabId }]" role="tab" :aria-selected="tab.id === activeTabId ? 'true' : 'false'" tabindex="0">
                                <span class="tab-title" :title="tab.title">[[ tab.title ]]</span>
                                <span v-if="tab.searching" class="tab-badge spinning" title="æœç´¢ä¸­">Â·Â·</span>
                                <span v-else-if="tab.hasSearched && tab.searchResults" class="tab-badge" :title="'åŒ¹é…: '+(tab.searchResults.total_matches||0)">[[ tab.searchResults.total_matches ]]</span>
                                <button type="button" class="close" @click.stop="closeTab(tab.id)" title="å…³é—­" aria-label="å…³é—­æ ‡ç­¾">Ã—</button>
                            </div>
                    </nav>

                    <!-- æœç´¢ç»“æœåŒºåŸŸ -->
                    <section class="results-section" ref="resultsWrapper" aria-label="æœç´¢ç»“æœ">

                        <!-- ä½¿ç”¨æ—¥å¿—æœç´¢ç»“æœç»„ä»¶ï¼ˆä»…åœ¨æœç´¢å®Œæˆåè¿›è¡Œé«˜äº®ï¼‰ -->
                        <log-search-results
                            :key="activeTab ? activeTab.resultsVersion : resultsVersion"
                            :search-results="activeTab ? activeTab.searchResults : searchResults"
                            :search-keyword="activeTab ? activeTab.highlightKeyword : highlightKeyword"
                            :use-regex="searchForm.use_regex"
                            :max-results="5000"
                            :show-search-stats="false"
                            :show-host-grouping="true"
                            :enabled-highlighters="effectiveHighlighters"
                            empty-message="æœªæ‰¾åˆ°åŒ¹é…çš„æ—¥å¿—è®°å½•"
                        />
                    </section>
                </main>
            </div>
    </div>

    <script>
        const { createApp } = Vue;
        const { ElMessage } = ElementPlus;

        // å¸¸é‡å®šä¹‰
        const CONSTANTS = {
            SEARCH_HISTORY_MAX: 10,
            DEFAULT_CONTEXT_SPAN: 30,
            MAX_LINES: 2000
        };

    const app = createApp({
            components: {
                LogSearchResults
            },
            data() {
                return {
                    // æ—¥å¿—åˆ—è¡¨
                    logs: [],
                    selectedLog: null,
                    logsLoading: false,
                    
                    // ä¾§è¾¹æ çŠ¶æ€
                    sidebarCollapsed: true,
                    sidebarPinned: false,
                    collapsedGroups: new Set(),
                    
                    // æœç´¢çŠ¶æ€
                    searching: false,
                    hasSearched: false,
                    resultsVersion: 0,
                    highlightKeyword: '',
                    searchInputFocused: false,
                    searchHistory: [],
                    
                    // æœç´¢è¡¨å•
                    searchForm: {
                        keyword: '',
                        search_mode: 'context',
                        context_span: CONSTANTS.DEFAULT_CONTEXT_SPAN,
                        use_regex: false,
                        reverse_order: false,
                        use_file_filter: false,
                        selected_files: {},
                        max_lines: CONSTANTS.MAX_LINES
                    },
                    
                    // SFTP æµè§ˆå™¨çŠ¶æ€
                    browsing: {
                        visible: false,
                        currentHost: '',
                        currentHostIndex: -1,
                        currentPath: '',
                        parentPath: null,
                        items: [],
                        connectionIds: {},
                        loading: {}
                    },
                    
                    // æœç´¢ç»“æœ
                    searchResults: null,
                    
                    // å¤šæ ‡ç­¾ç®¡ç†
                    tabs: [],
                    activeTabId: null,
                    nextTabSeq: 1
                };
            },

            computed: {
                // æŒ‰åˆ†ç»„ç»„ç»‡çš„æ—¥å¿—åˆ—è¡¨
                groupedLogs() {
                    const groups = {};
                    this.logs.forEach(log => {
                        const groupName = log.group || 'é»˜è®¤åˆ†ç»„';
                        if (!groups[groupName]) {
                            groups[groupName] = [];
                        }
                        groups[groupName].push(log);
                    });

                    return Object.keys(groups).map(groupName => ({
                        name: groupName,
                        logs: groups[groupName].sort((a, b) => a.name.localeCompare(b.name)),
                        isCollapsed: this.collapsedGroups.has(groupName)
                    })).sort((a, b) => {
                        if (a.name === 'é»˜è®¤åˆ†ç»„' && b.name !== 'é»˜è®¤åˆ†ç»„') return 1;
                        if (b.name === 'é»˜è®¤åˆ†ç»„' && a.name !== 'é»˜è®¤åˆ†ç»„') return -1;
                        return a.name.localeCompare(b.name);
                    });
                },
                
                // æŒ‰ä¸»æœºåˆ†ç»„çš„æ–‡ä»¶åˆ—è¡¨
                groupedFiles() {
                    if (!this.selectedLog?.sshs?.length) {
                        return [];
                    }
                    
                    const sshs = this.selectedLog.sshs;
                    const hostCount = {};
                    sshs.forEach(s => { 
                        const h = s.host || 'unknown'; 
                        hostCount[h] = (hostCount[h] || 0) + 1; 
                    });
                    
                    return sshs.map((s, idx) => {
                        const host = s.host || 'unknown';
                        const displayHost = hostCount[host] > 1 ? `${host}#${idx + 1}` : host;
                        const key = `${host}|${idx}`;
                        
                        let files = [];
                        if (this.browsing.currentHost === host && 
                            this.browsing.currentHostIndex === idx && 
                            this.browsing.items.length) {
                            files = this.browsing.items
                                .filter(i => !i.is_directory)
                                .map(i => ({
                                    host,
                                    filename: i.name,
                                    full_path: this.joinPath(this.browsing.currentPath, i.name)
                                }));
                        }
                        
                        return { 
                            key, 
                            host: displayHost, 
                            originalHost: host, 
                            sshIndex: idx, 
                            files: files.sort((a, b) => a.filename.localeCompare(b.filename))
                        };
                    });
                },
                
                // æµè§ˆå™¨åŠ è½½çŠ¶æ€
                isBrowsingLoading() {
                    return this.browsing?.currentHost && !!this.browsing.loading[this.browsing.currentHost];
                },

                // å½“å‰æ¿€æ´»æ ‡ç­¾
                activeTab() { 
                    return this.tabs.find(t => t.id === this.activeTabId) || null; 
                },

                // é«˜äº®å™¨å¼€å…³
                effectiveHighlighters() {
                    const tab = this.activeTab;
                    const isReady = tab && tab.hasSearched && !tab.searching && tab.searchResults;
                    
                    return {
                        logLevels: isReady,
                        timestamps: isReady,
                        network: isReady,
                        xml: isReady,
                        sql: isReady,
                        json: isReady,
                        filePaths: isReady,
                        urls: isReady,
                        emails: isReady,
                        uuids: isReady
                    };
                }
            },

            mounted() {
                this.loadLogs();
                this.loadSearchHistory();
                this.loadSidebarPinState();
                
                // å…¨å±€å›è½¦é”®ç›‘å¬
                document.addEventListener('keydown', this.handleGlobalKeydown);
            },

            beforeUnmount() {
                document.removeEventListener('keydown', this.handleGlobalKeydown);
            },

            methods: {
                // ============ ä¾§è¾¹æ æ§åˆ¶ ============
                toggleSidebarPin() {
                    this.sidebarPinned = !this.sidebarPinned;
                    this.sidebarCollapsed = !this.sidebarPinned;
                    this.saveSidebarPinState();
                },
                
                loadSidebarPinState() {
                    try {
                        const pin = localStorage.getItem('sidebarPinned');
                        this.sidebarPinned = pin === '1';
                        if (this.sidebarPinned) this.sidebarCollapsed = false;
                    } catch (e) { 
                        console.warn('Failed to load sidebar state:', e);
                    }
                },
                
                saveSidebarPinState() {
                    try { 
                        localStorage.setItem('sidebarPinned', this.sidebarPinned ? '1' : '0'); 
                    } catch(e) { 
                        console.warn('Failed to save sidebar state:', e);
                    }
                },
                
                toggleGroup(groupName) {
                    if (this.collapsedGroups.has(groupName)) {
                        this.collapsedGroups.delete(groupName);
                    } else {
                        this.collapsedGroups.add(groupName);
                    }
                },
                
                // ============ é”™è¯¯å¤„ç† ============
                handleApiError(error, defaultMessage = 'æ“ä½œå¤±è´¥') {
                    const errorInfo = error.response?.data?.error || error.error || {};
                    let errorMessage = defaultMessage;
                    
                    const errorMessages = {
                        'VALIDATION_ERROR': `å‚æ•°é”™è¯¯: ${errorInfo.message}`,
                        'INVALID_CONTEXT_SPAN': 'ä¸Šä¸‹æ–‡è¡Œæ•°è®¾ç½®æ— æ•ˆï¼Œè¯·è®¾ç½®ä¸º0-50ä¹‹é—´çš„æ•´æ•°',
                        'INVALID_SEARCH_MODE': 'æœç´¢æ¨¡å¼æ— æ•ˆï¼Œè¯·é€‰æ‹©æ­£ç¡®çš„æœç´¢æ–¹å¼',
                        'INVALID_FILE_FILTER': 'æ–‡ä»¶è¿‡æ»¤è®¾ç½®æ— æ•ˆï¼Œå¯ç”¨è¿‡æ»¤æ—¶è¯·æŒ‡å®šè¦æœç´¢çš„æ–‡ä»¶',
                        'CONNECTION_ERROR': `è¿æ¥å¤±è´¥: ${errorInfo.message || 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'}`,
                        'DEADLINE_EXCEEDED': `æ“ä½œè¶…æ—¶: ${errorInfo.message || 'è¯·ç¨åé‡è¯•'}`,
                        'NOT_FOUND': errorInfo.message || 'èµ„æºä¸å­˜åœ¨',
                        'PERMISSION_DENIED': `æƒé™ä¸è¶³: ${errorInfo.message || 'è¯·è”ç³»ç®¡ç†å‘˜'}`,
                        'INTERNAL': 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•'
                    };
                    
                    errorMessage = errorMessages[errorInfo.code] || errorInfo.message || defaultMessage;
                    ElMessage.error(errorMessage);
                    
                    if (errorInfo.details) {
                        console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', errorInfo.details);
                    }
                },
                
                // ============ æ—¥å¿—ç®¡ç† ============
                async loadLogs() {
                    this.logsLoading = true;
                    try {
                        const response = await axios.get('/api/v1/logs');
                        if (response.data.success) {
                            this.logs = response.data.data.logs || [];
                            this.initializeGroupsCollapsed();
                        } else {
                            this.handleApiError({ response: { data: response.data } }, 'åŠ è½½æ—¥å¿—åˆ—è¡¨å¤±è´¥');
                        }
                    } catch (error) {
                        this.handleApiError(error, 'è¿æ¥æœåŠ¡å™¨å¤±è´¥');
                        console.error('åŠ è½½æ—¥å¿—å¤±è´¥:', error);
                    } finally {
                        this.logsLoading = false;
                    }
                },
                
                initializeGroupsCollapsed() {
                    this.collapsedGroups.clear();
                    const groups = new Set();
                    this.logs.forEach(log => {
                        const groupName = log.group || 'é»˜è®¤åˆ†ç»„';
                        groups.add(groupName);
                    });
                    groups.forEach(groupName => {
                        this.collapsedGroups.add(groupName);
                    });
                },

                selectLog(log) {
                    if (!log) return;
                    
                    // è‹¥å·²æœ‰å¯¹åº”æ ‡ç­¾åˆ™æ¿€æ´»
                    const exist = this.tabs.find(t => t.logName === log.name);
                    if (exist) { 
                        this.activateTab(exist.id); 
                        return; 
                    }
                    
                    // åˆ›å»ºæ–°æ ‡ç­¾
                    const tab = this.createTabForLog(log);
                    this.tabs.push(tab);
                    this.activeTabId = tab.id;
                    this.syncActiveTabToRoot();
                    
                    // æ„å»ºå ä½ & æ‹‰å–è¯¦æƒ…
                    this.buildPlaceholderResults(tab);
                    this.ensureLogDetail(log).then(() => {
                        if (tab.searchResults?.pre_search) {
                            this.buildPlaceholderResults(tab);
                        }
                    });
                },

                async ensureLogDetail(log) {
                    if (!log || log.sshs || !log.name) return;
                    
                    try {
                        const resp = await axios.get(`/api/v1/logs/${log.name}`);
                        if (resp.data.success && resp.data.data) {
                            const detail = resp.data.data;
                            log.sshs = detail.ssh_configs || [];
                            
                            if (this.selectedLog === log) {
                                this.selectedLog.sshs = log.sshs;
                                if (!this.hasSearched) {
                                    this.buildPlaceholderResults();
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('è·å–æ—¥å¿—è¯¦ç»†é…ç½®å¤±è´¥', e);
                    }
                },
                
                // ============ æœç´¢åŠŸèƒ½ ============
                async executeSearch() {
                    if (this.searchForm.keyword) {
                        this.addSearchHistory(this.searchForm.keyword);
                    }
                    this.searchInputFocused = false;
                    
                    const tab = this.activeTab;
                    if (!tab || !this.selectedLog) {
                        ElMessage.warning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ—¥å¿—é…ç½®');
                        return;
                    }
                    
                    if (this.searchForm.use_file_filter) {
                        this.showFileFilterInfo();
                    }
                    
                    this.buildPlaceholderResults(tab);
                    tab.highlightKeyword = '';
                    await this.$nextTick();
                    
                    tab.searching = true;
                    tab.hasSearched = true;
                    
                    try {
                        const response = await axios.post(
                            `/api/v1/logs/${this.selectedLog.name}/search`, 
                            this.searchForm
                        );
                        
                        if (response.data.success) {
                            tab.searchResults = response.data.data;
                            if (tab.searchResults) tab.searchResults.pre_search = false;
                            tab.highlightKeyword = this.searchForm.keyword || '';
                            tab.resultsVersion += 1;
                            
                            const count = tab.searchResults.total_matches;
                            if (count === 0) {
                                ElMessage.info('æœªæ‰¾åˆ°åŒ¹é…çš„æ—¥å¿—è®°å½•');
                            } else {
                                ElMessage.success(`æ‰¾åˆ° ${count} ä¸ªåŒ¹é…é¡¹`);
                            }
                        } else {
                            this.handleApiError({ response: { data: response.data } }, 'æœç´¢å¤±è´¥');
                            tab.searchResults = null;
                            tab.highlightKeyword = '';
                        }
                    } catch (e) {
                        this.handleApiError(e, 'æœç´¢è¯·æ±‚å¤±è´¥');
                        console.error('æœç´¢å¤±è´¥:', e);
                        tab.searchResults = null;
                        tab.highlightKeyword = '';
                    } finally {
                        tab.searching = false;
                    }
                },
                
                showFileFilterInfo() {
                    const totalHosts = this.groupedFiles.length;
                    const chosen = Object.keys(this.searchForm.selected_files || {}).length;
                    
                    if (chosen === 0) {
                        ElMessage.info('æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶ï¼Œå°†ä½¿ç”¨é…ç½®é»˜è®¤è·¯å¾„');
                    } else if (chosen < totalHosts) {
                        ElMessage.info(`éƒ¨åˆ†ä¸»æœºæœªé€‰æ–‡ä»¶ï¼ˆ${chosen}/${totalHosts}ï¼‰ï¼Œæœªé€‰çš„å°†ç”¨é»˜è®¤è·¯å¾„`);
                    }
                },
                
                toggleSearchMode() {
                    this.searchForm.search_mode = this.searchForm.search_mode === 'keyword' ? 'context' : 'keyword';
                    const mode = this.searchForm.search_mode === 'keyword' ? 'å…³é”®è¯æœç´¢' : 'ä¸Šä¸‹æ–‡æœç´¢';
                    ElMessage.info(`å·²åˆ‡æ¢åˆ°${mode}æ¨¡å¼`);
                },

                toggleFileFilter() {
                    this.searchForm.use_file_filter = !this.searchForm.use_file_filter;
                    
                    if (this.searchForm.use_file_filter) {
                        ElMessage.info('å·²å¯ç”¨æ–‡ä»¶è¿‡æ»¤ï¼Œå¯é€šè¿‡"æµè§ˆ"é€‰æ‹©æ–‡ä»¶');
                    } else {
                        this.searchForm.selected_files = {};
                        ElMessage.info('å·²å…³é—­æ–‡ä»¶è¿‡æ»¤');
                    }
                },
                
                // ============ æœç´¢å†å² ============
                loadSearchHistory() {
                    try {
                        const history = localStorage.getItem('searchHistory');
                        if (history) {
                            this.searchHistory = JSON.parse(history).slice(0, CONSTANTS.SEARCH_HISTORY_MAX);
                        }
                    } catch (e) {
                        console.error('Failed to load search history', e);
                        this.searchHistory = [];
                    }
                },
                
                saveSearchHistory() {
                    try {
                        localStorage.setItem('searchHistory', JSON.stringify(this.searchHistory));
                    } catch (e) {
                        console.error('Failed to save search history', e);
                    }
                },
                
                addSearchHistory(keyword) {
                    if (!keyword) return;
                    
                    const index = this.searchHistory.indexOf(keyword);
                    if (index > -1) {
                        this.searchHistory.splice(index, 1);
                    }
                    
                    this.searchHistory.unshift(keyword);
                    
                    if (this.searchHistory.length > CONSTANTS.SEARCH_HISTORY_MAX) {
                        this.searchHistory = this.searchHistory.slice(0, CONSTANTS.SEARCH_HISTORY_MAX);
                    }
                    
                    this.saveSearchHistory();
                },
                
                selectHistory(item) {
                    this.searchForm.keyword = item;
                    this.searchInputFocused = false;
                },

                // ============ å ä½ç»“æœ ============
                buildPlaceholderResults(tab = null) {
                    tab = tab || this.activeTab;
                    if (!tab) return;
                    
                    const logRef = tab.selectedLog || this.selectedLog;
                    if (!logRef?.sshs?.length) {
                        tab.searchResults = null;
                        tab.resultsVersion += 1;
                        if (tab.id === this.activeTabId) { 
                            this.searchResults = null; 
                            this.resultsVersion = tab.resultsVersion; 
                        }
                        return;
                    }
                    
                    const hosts = logRef.sshs.map((s, idx) => ({
                        host: s.host || 'unknown',
                        ssh_index: idx,
                        results: [],
                        total_results: 0,
                        search_time: 0,
                        search_result: { 
                            content: '', 
                            file_path: '', 
                            keyword: '', 
                            total_lines: 0, 
                            search_time: 0, 
                            matches: [] 
                        },
                        success: true
                    }));
                    
                    tab.searchResults = {
                        log_name: logRef.name,
                        keyword: '',
                        search_params: {},
                        total_hosts: hosts.length,
                        hosts,
                        total_results: 0,
                        total_matches: 0,
                        total_search_time: 0,
                        parallel_execution: false,
                        pre_search: true
                    };
                    
                    tab.resultsVersion += 1;
                    
                    if (tab.id === this.activeTabId) {
                        this.searchResults = tab.searchResults;
                        this.resultsVersion = tab.resultsVersion;
                    }
                },

                // ============ é”®ç›˜äº‹ä»¶ ============
                handleGlobalKeydown(event) {
                    // å›è½¦é”®æœç´¢
                    if (event.key === 'Enter' &&
                        !['INPUT', 'TEXTAREA'].includes(event.target.tagName) &&
                        !event.target.isContentEditable) {
                        event.preventDefault();
                        event.stopPropagation();
                        this.executeSearch();
                    }
                },

                // ============ SFTP æµè§ˆå™¨ ============
                async openSftpBrowser(groupOrHost) {
                    if (!this.selectedLog) {
                        ElMessage.error('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ—¥å¿—é…ç½®');
                        return;
                    }
                    
                    if (!this.selectedLog.sshs) {
                        await this.ensureLogDetail(this.selectedLog);
                    }
                    
                    if (!this.selectedLog.sshs) {
                        ElMessage.error('å½“å‰æ—¥å¿—é…ç½®ç¼ºå°‘ SSH ä¿¡æ¯');
                        return;
                    }
                    
                    const { sshIndex, host } = this.parseGroupOrHost(groupOrHost);
                    
                    if (sshIndex == null || sshIndex < 0 || sshIndex >= this.selectedLog.sshs.length) {
                        ElMessage.error('æœªæ‰¾åˆ°å¯¹åº”ä¸»æœº SSH é…ç½®');
                        return;
                    }
                    
                    this.browsing.currentHost = host;
                    this.browsing.currentHostIndex = sshIndex;
                    this.browsing.visible = true;
                    
                    await this.ensureSftpConnection(host, sshIndex);
                    await this.navigateToInitialPath(host, sshIndex);
                },
                
                parseGroupOrHost(groupOrHost) {
                    let sshIndex, host;
                    
                    if (typeof groupOrHost === 'string') {
                        host = groupOrHost;
                        sshIndex = this.selectedLog.sshs.findIndex(s => s.host === host);
                    } else {
                        host = groupOrHost.originalHost;
                        sshIndex = groupOrHost.sshIndex;
                    }
                    
                    return { sshIndex, host };
                },
                
                async navigateToInitialPath(host, sshIndex) {
                    try {
                        const sshCfg = this.selectedLog.sshs[sshIndex] || {};
                        const originalPath = (sshCfg.path || this.selectedLog.path || '/') || '/';
                        const hasPlaceholder = /\{[^}]+\}/.test(originalPath);

                        if (hasPlaceholder) {
                            await this.navigateWithPlaceholder(host, originalPath);
                        } else {
                            await this.navigateWithoutPlaceholder(host, originalPath);
                        }
                    } catch (e) {
                        console.error('è®¡ç®—åˆå§‹ç›®å½•å¤±è´¥', e);
                    }
                },
                
                async navigateWithPlaceholder(host, originalPath) {
                    const resolvedPath = this.replaceDatePlaceholders(originalPath);
                    const primaryDir = this.normalizeDir(this.parentDir(
                        resolvedPath.endsWith('/') ? resolvedPath.slice(0, -1) : resolvedPath
                    ));
                    const baseName = resolvedPath.slice(resolvedPath.lastIndexOf('/') + 1) || '';
                    const nameMatcher = this.buildNameMatcher(baseName);
                    
                    const phIdx = originalPath.search(/\{[^}]+\}/);
                    let fallbackBase = phIdx >= 0 ? originalPath.slice(0, phIdx) : originalPath;
                    if (!fallbackBase.endsWith('/')) fallbackBase = this.parentDir(fallbackBase);
                    const fallbackDir = this.normalizeDir(fallbackBase || '/');

                    try {
                        const data = await this.probePath(host, primaryDir);
                        const items = Array.isArray(data.items) ? data.items : [];
                        const found = items.some(it => !it.is_directory && this.matchesName(it.name, nameMatcher));
                        
                        this.listRemotePath(host, found ? primaryDir : fallbackDir);
                    } catch (err) {
                        this.listRemotePath(host, fallbackDir);
                    }
                },
                
                async navigateWithoutPlaceholder(host, originalPath) {
                    let raw = originalPath;
                    if (!raw.endsWith('/')) raw = this.parentDir(raw);
                    raw = this.normalizeDir(raw);
                    this.listRemotePath(host, raw);
                },

                async refreshCurrent() {
                    if (!this.selectedLog) return;
                    
                    const { currentHost, currentHostIndex, currentPath } = this.browsing;
                    if (!currentHost || currentHostIndex == null || currentHostIndex < 0) return;
                    
                    this.listRemotePath(currentHost, currentPath || '/');
                },

                async ensureSftpConnection(host, sshIndex) {
                    if (this.browsing.connectionIds[host]) return;
                    
                    this.browsing.loading[host] = true;
                    try {
                        const resp = await axios.post('/api/v1/sftp/connect-by-config', { 
                            log_name: this.selectedLog.name, 
                            ssh_index: sshIndex 
                        });
                        
                        if (resp.data.success) {
                            this.browsing.connectionIds[host] = resp.data.data.connection_id;
                        } else {
                            this.handleApiError({ response: { data: resp.data } }, 'SFTPè¿æ¥å¤±è´¥');
                        }
                    } catch (e) {
                        this.handleApiError(e, 'SFTPè¿æ¥è¯·æ±‚å¤±è´¥');
                    } finally {
                        this.browsing.loading[host] = false;
                    }
                },

                async listRemotePath(host, path) {
                    const cid = this.browsing.connectionIds[host];
                    if (!cid) return;
                    
                    this.browsing.loading[host] = true;
                    try {
                        const resp = await axios.post('/api/v1/sftp/list', { 
                            connection_id: cid, 
                            path 
                        });
                        
                        if (resp.data.success) {
                            const data = resp.data.data;
                            this.browsing.currentPath = data.current_path;
                            this.browsing.parentPath = data.parent_path;
                            this.browsing.items = data.items || [];
                        } else {
                            this.handleApiError({ response: { data: resp.data } }, 'åˆ—å‡ºç›®å½•å¤±è´¥');
                        }
                    } catch (e) {
                        this.handleApiError(e, 'åˆ—å‡ºç›®å½•è¯·æ±‚å¤±è´¥');
                    } finally {
                        this.browsing.loading[host] = false;
                    }
                },
                
                async probePath(host, dir) {
                    const cid = this.browsing.connectionIds[host];
                    if (!cid) throw new Error('no connection');
                    
                    const resp = await axios.post('/api/v1/sftp/list', { 
                        connection_id: cid, 
                        path: dir 
                    });
                    
                    if (!resp.data.success) {
                        throw Object.assign(new Error('list failed'), { response: resp });
                    }
                    
                    return resp.data.data;
                },

                handleBrowserDblClick(row) {
                    if (!row) return;
                    
                    if (row.is_directory) {
                        const p = this.joinPath(this.browsing.currentPath, row.name);
                        this.listRemotePath(this.browsing.currentHost, p);
                    } else {
                        const full = this.joinPath(this.browsing.currentPath, row.name);
                        const key = `${this.browsing.currentHost}|${this.browsing.currentHostIndex}`;
                        this.searchForm.selected_files[key] = full;
                        ElMessage.success('å·²é€‰æ‹©æ–‡ä»¶: ' + row.name);
                        this.closeBrowser();
                    }
                },

                goParent() {
                    if (!this.browsing.parentPath) return;
                    this.listRemotePath(this.browsing.currentHost, this.browsing.parentPath);
                },
                
                closeBrowser() {
                    this.browsing.visible = false;
                },
                
                clearSelectedFile(group) {
                    if (!group) return;
                    delete this.searchForm.selected_files[group.key];
                },
                
                // ============ æ ‡ç­¾ç®¡ç† ============
                createTabForLog(log) {
                    return {
                        id: 'tab_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
                        logName: log.name,
                        title: log.name,
                        selectedLog: log,
                        searchForm: null,
                        searchResults: null,
                        highlightKeyword: '',
                        hasSearched: false,
                        searching: false,
                        resultsVersion: 0
                    };
                },
                
                syncActiveTabToRoot() {
                    const tab = this.activeTab;
                    if (!tab) return;
                    
                    this.selectedLog = tab.selectedLog;
                    this.searchResults = tab.searchResults;
                    this.highlightKeyword = tab.highlightKeyword;
                    this.hasSearched = tab.hasSearched;
                    this.searching = tab.searching;
                    this.resultsVersion = tab.resultsVersion;
                },
                
                activateTab(id) {
                    if (this.activeTabId === id) return;
                    
                    const tab = this.tabs.find(t => t.id === id);
                    if (!tab) return;
                    
                    this.activeTabId = id;
                    this.syncActiveTabToRoot();
                },
                
                closeTab(id) {
                    const idx = this.tabs.findIndex(t => t.id === id);
                    if (idx === -1) return;
                    
                    const closingActive = this.tabs[idx].id === this.activeTabId;
                    this.tabs.splice(idx, 1);
                    
                    if (!this.tabs.length) {
                        this.resetToInitialState();
                    } else if (closingActive) {
                        const newTab = this.tabs[Math.max(0, idx - 1)];
                        this.activeTabId = newTab.id;
                        this.syncActiveTabToRoot();
                    }
                },
                
                resetToInitialState() {
                    this.selectedLog = null;
                    this.activeTabId = null;
                    this.searchForm = {
                        keyword: '',
                        search_mode: 'context',
                        context_span: CONSTANTS.DEFAULT_CONTEXT_SPAN,
                        use_regex: false,
                        reverse_order: false,
                        use_file_filter: false,
                        selected_files: {},
                        max_lines: CONSTANTS.MAX_LINES
                    };
                    this.searchResults = null;
                    this.highlightKeyword = '';
                    this.hasSearched = false;
                    this.searching = false;
                    this.resultsVersion = 0;
                },
                
                // ============ å·¥å…·å‡½æ•° ============
                formatDisplayPath(p) {
                    if (!p) return '';
                    return p.length > 80 ? p.slice(0, 35) + ' ... ' + p.slice(-35) : p;
                },
                
                formatDateTime(timeStr) {
                    if (!timeStr) return 'æœªçŸ¥';
                    try {
                        const date = new Date(timeStr);
                        return date.toLocaleString('zh-CN', {
                            year: 'numeric', month: '2-digit', day: '2-digit',
                            hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
                        });
                    } catch (e) { 
                        return timeStr; 
                    }
                },
                
                // è·¯å¾„å¤„ç†å·¥å…·
                normalizeDir(p) {
                    let s = (p || '/').replace(/\/+/g, '/');
                    if (s !== '/' && s.endsWith('/')) s = s.replace(/\/+$/, '');
                    if (!s) s = '/';
                    return s;
                },
                
                parentDir(p) {
                    if (!p) return '/';
                    const i = p.lastIndexOf('/');
                    if (i <= 0) return '/';
                    return p.slice(0, i) || '/';
                },
                
                joinPath(dir, name) {
                    return (dir === '/' ? '/' : dir + '/') + name;
                },
                
                replaceDatePlaceholders(p) {
                    const now = new Date();
                    const pad2 = (n) => (n < 10 ? '0' + n : '' + n);
                    const YYYY = '' + now.getFullYear();
                    const MM = pad2(now.getMonth() + 1);
                    const DD = pad2(now.getDate());
                    
                    return p
                        .replace(/\{YYYY\}/g, YYYY)
                        .replace(/\{MM\}/g, MM)
                        .replace(/\{DD\}/g, DD);
                },
                
                buildNameMatcher(basename) {
                    if (basename.includes('{N}')) {
                        const pattern = '^' + basename.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
                            .replace(/\\\{N\\\}/g, '\\d+') + '$';
                        return new RegExp(pattern);
                    }
                    return basename;
                },
                
                matchesName(name, matcher) {
                    if (matcher instanceof RegExp) {
                        return matcher.test(name);
                    }
                    return matcher ? name === matcher : false;
                }
            }
        });

        // è®¾ç½®æ’å€¼åˆ†éš”ç¬¦
        if (app.config?.compilerOptions) {
            app.config.compilerOptions.delimiters = ['[[', ']]'];
        }

        app.use(ElementPlus);
        app.mount('#app');
    </script>
</body>
</html>
