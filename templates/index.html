<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥å¿—èšåˆæœç´¢</title>
    <link rel="icon" href="/static/icons/favicon-search.svg" />

    <!-- æœ¬åœ°èµ„æº -->
    <!-- Element Plus CSS -->
    <link rel="stylesheet" href="/static/css/element-plus.css" />
    <!-- Prism.js CSSä¸»é¢˜ -->
    <link rel="stylesheet" href="/static/css/prism-okaidia.min.css" />
    <!-- è‡ªå®šä¹‰CSS -->
    <link rel="stylesheet" href="/static/fonts/microsoft-yahei.css" />
    <link rel="stylesheet" href="/static/css/main.css" />
    <link rel="stylesheet" href="/static/css/groups.css" />
    <link rel="stylesheet" href="/static/css/search.css" />
    <link rel="stylesheet" href="/static/css/results.css" />
    <!-- ç´§å‡‘æ ·å¼è¦†ç›–ï¼Œç¼©å°æ•´ä½“å­—å·ä¸é—´è·çº¦10% -->
    <link rel="stylesheet" href="/static/css/compact.css" />
    <style>
        /* æ–‡ä»¶è¿‡æ»¤å™¨å±•å¼€/æŠ˜å è¿‡æ¸¡åŠ¨ç”» */
        .file-filter-enter-from,
        .file-filter-leave-to {
            max-height: 0;
            opacity: 0;
            transform: translateY(-4px);
        }
        .file-filter-enter-to,
        .file-filter-leave-from {
            max-height: 800px; /* å…è®¸è¶³å¤Ÿé«˜åº¦ */
            opacity: 1;
            transform: translateY(0);
        }
        .file-filter-enter-active,
        .file-filter-leave-active {
            overflow: hidden;
            transition: max-height .28s ease, opacity .25s ease, transform .28s ease;
        }

        /* æ—¥å¿—ç»“æœæ ‡ç­¾æ ï¼šæ•´ä½“ç™½åº•åœ†è§’å®¹å™¨ + å•ä¸ªæ ‡ç­¾ç™½è‰²/é€‰ä¸­æµ…è“ */
        .log-tabs-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 10px;
            padding: 16px 16px 16px 16px; /* ä¸ search-section ç»Ÿä¸€çš„å†…è¾¹è·é£æ ¼ */
            background: #fff;
            border-radius: 8px; /* ç»Ÿä¸€åœ†è§’ */
            /* box-shadow: 0 2px 12px rgba(0,0,0,0.1); åŒ search-section */
            margin: 0 0 0 0;
        }
        .log-tab-item {
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 240px;
            padding: 8px 18px;
            font-size: 14px;
            line-height: 1.25;
            border-radius: 8px;
            background: #fff;
            color: var(--el-text-color-regular);
            cursor: pointer;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08), inset 0 0 0 1px var(--el-border-color-extra-light);
            transition: background .15s ease, color .15s ease, box-shadow .18s ease, transform .16s ease;
        }
    .log-tab-item:hover { background: #f5f7fa; }
        .log-tab-item.active {
            background: #ecf5ff; /* æµ…è“ï¼Œä¸æ•´ä½“é£æ ¼åè°ƒ */
            color: var(--el-color-primary);
            font-weight: 600;
            box-shadow: 0 1px 4px rgba(64,158,255,0.25), inset 0 0 0 1px var(--el-color-primary-light-5);
        }
    .log-tab-item .tab-title { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; text-align:center; }
    .log-tab-item .close { font-size:14px; line-height:1; color:var(--el-text-color-placeholder); padding:2px; border-radius:3px; transition:background .15s ease, color .15s ease; opacity:1; }
    .log-tab-item:hover .close { opacity:1; }
    .log-tab-item .close:hover { color:var(--el-color-danger); background:var(--el-fill-color); }
    .log-tab-item .tab-badge { font-size:10px; line-height:16px; min-width:20px; padding:0 6px; border-radius:10px; background:#eef2f6; color:var(--el-text-color-secondary); text-align:center; font-weight:500; }
    .log-tab-item.active .tab-badge { background:#d3e9ff; color:var(--el-color-primary); }
    .log-tab-item .tab-badge.spinning { animation:tabPulse 1s linear infinite; }
    @keyframes tabPulse { 0% {opacity:.35;} 50% {opacity:1;} 100% {opacity:.35;} }
    .results-section { margin-top:0; }
    /* .right-panel { background:var(--el-bg-color); } */
    .search-section { border-bottom:1px solid var(--el-border-color-light); }
    </style>
    
    <!-- æœ¬åœ°JavaScriptåº“ -->
    <script src="/static/js/vendor/vue.global.js"></script>
    <script src="/static/js/vendor/element-plus.js"></script>
    <script src="/static/js/vendor/axios.min.js"></script>
    <!-- Prism.jsåº“ -->
    <script src="/static/js/vendor/prism-core.min.js"></script>
    <script src="/static/js/vendor/prism-markup.min.js"></script>
    <script src="/static/js/vendor/prism-clike.min.js"></script>
    <script src="/static/js/vendor/prism-javascript.min.js"></script>
    <script src="/static/js/vendor/prism-json.min.js"></script>
    <script src="/static/js/vendor/prism-sql.min.js"></script>
    <script src="/static/js/vendor/prism-xml-doc.min.js"></script>
    <!-- LogSearchResults ç»„ä»¶ -->
    <script src="/static/js/LogSearchResults.js"></script>

</head>

<body>
    <script>window.APP_PAGE="{{ page|default('') }}";</script>
    <div id="app">
        <div class="app-container">


            <!-- ä¸»å†…å®¹åŒºåŸŸ -->
            <div class="main-content">
                <!-- å·¦ä¾§æ—¥å¿—åˆ—è¡¨ -->
                <div class="left-panel">
                    <div class="panel-header">
                        <h3>ğŸ” æ—¥å¿—èšåˆæœç´¢</h3>
                    </div>
                    <div class="log-list" v-loading="logsLoading">
                        <div v-if="logs.length === 0 && !logsLoading" class="empty-state">
                            <div>æš‚æ— æ—¥å¿—é…ç½®</div>
                        </div>
                        
                        <!-- åˆ†ç»„æ˜¾ç¤º -->
                        <div v-for="group in groupedLogs" :key="group.name" class="log-group">
                            <!-- åˆ†ç»„æ ‡é¢˜ -->
                            <div class="group-header" @click="toggleGroup(group.name)">
                                <span class="group-name">[[ group.name ]]</span>
                                <span class="group-count">([[ group.logs.length ]])</span>
                                <span class="toggle-icon" :class="{ collapsed: group.isCollapsed }">â–¼</span>
                            </div>
                            
                            <!-- åˆ†ç»„å†…çš„æ—¥å¿—åˆ—è¡¨ -->
                            <div v-show="!group.isCollapsed" class="group-content">
                                <div v-for="log in group.logs" :key="log.name" class="log-item"
                                    :class="{ active: selectedLog?.name === log.name }" @click="selectLog(log)">
                                    <h4>[[ log.name ]]</h4>
                                    <p>[[ log.description || 'æš‚æ— æè¿°' ]]</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- æ›´å¤šåŠŸèƒ½æŒ‰é’® -->
                    <!-- ä¸´æ—¶éšè—æ›´å¤šå·¥å…·å…¥å£: ç”¨æˆ·è¯·æ±‚ "æš‚æ—¶éšè—æ›´å¤šå·¥å…·å…¥å£" -->
                    <div class="more-actions" style="display:none;" aria-hidden="true">
                        <button class="more-button" @click="toggleMoreMenu" :class="{ active: showMoreMenu }">
                            <span class="more-icon">âš™ï¸</span>
                            <span class="more-text">æ›´å¤šåŠŸèƒ½</span>
                            <span class="arrow-icon" :class="{ rotated: showMoreMenu }">â–¼</span>
                        </button>
                        
                        <!-- æ›´å¤šåŠŸèƒ½èœå• -->
                        <div v-show="showMoreMenu" class="more-menu">
                            <!-- æ—¥å¿—é…ç½®é¡µé¢å·²éšè— - ä¸å¼€æ”¾ç»™ç”¨æˆ·æ‰‹åŠ¨é…ç½®
                            <div class="menu-item" @click="navigateToPage('config')">
                                <span class="menu-icon">âš™ï¸</span>
                                <span class="menu-text">æ—¥å¿—é…ç½®</span>
                            </div>
                            -->
                            <div class="menu-item" @click="navigateToPage('sftp')">
                                <span class="menu-icon">ğŸ“</span>
                                <span class="menu-text">æ–‡ä»¶ç®¡ç†</span>
                            </div>
                            <div class="menu-item" @click="navigateToPage('terminals')">
                                <span class="menu-icon">ğŸ’»</span>
                                <span class="menu-text">åœ¨çº¿ç»ˆç«¯</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- å³ä¾§æœç´¢å’Œç»“æœåŒºåŸŸ -->
                <div class="right-panel">
                    <!-- æœç´¢åŒºåŸŸ -->
                    <div class="search-section">


                        <el-form :model="searchForm" class="search-form" :disabled="!selectedLog" @submit.prevent="executeSearch">
                            <!-- ä¸»æœç´¢æ¡†å®¹å™¨ -->
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <div class="search-input-container" :class="{ focused: searchInputFocused }" style="flex: 1;">
                                    <input type="text" v-model="searchForm.keyword" placeholder="è¾“å…¥æœç´¢å…³é”®è¯ï¼Œç•™ç©ºåˆ™æ˜¾ç¤ºæœ€æ–°æ—¥å¿—"
                                        class="search-input" @focus="searchInputFocused = true"
                                        @blur="searchInputFocused = false" @keyup.enter="executeSearch"
                                        :disabled="!selectedLog" />

                                    <!-- æœç´¢è®¾ç½®æŒ‰é’®ç»„ -->
                                    <div class="search-buttons">
                                        <!-- æœç´¢æ¨¡å¼åˆ‡æ¢ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.search_mode === 'context' }"
                                            @click="toggleSearchMode" :disabled="!selectedLog" title="æœç´¢æ¨¡å¼">
                                            <span v-if="searchForm.search_mode === 'keyword'">âš¡</span>
                                            <span v-else>ğŸ“„</span>
                                        </button>

                                        <!-- æ­£åˆ™è¡¨è¾¾å¼ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.use_regex }"
                                            @click="searchForm.use_regex = !searchForm.use_regex" :disabled="!selectedLog"
                                            title="æ­£åˆ™è¡¨è¾¾å¼">
                                            .*
                                        </button>

                                        <!-- é€†åºæœç´¢ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.reverse_order }"
                                            @click="searchForm.reverse_order = !searchForm.reverse_order"
                                            :disabled="!selectedLog" title="é€†åºæœç´¢">
                                            <span v-if="searchForm.reverse_order">â¬†ï¸</span>
                                            <span v-else>â¬‡ï¸</span>
                                        </button>

                                        <!-- æŒ‡å®šæ–‡ä»¶æœç´¢ -->
                                        <button type="button" class="search-button"
                                            :class="{ active: searchForm.use_file_filter }" @click="toggleFileFilter"
                                            :disabled="!selectedLog" title="æŒ‡å®šæ–‡ä»¶æœç´¢">
                                            ğŸ“
                                        </button>

                                        <!-- ä¸Šä¸‹æ–‡è¡Œæ•° - åªåœ¨ä¸Šä¸‹æ–‡æ¨¡å¼æ—¶æ˜¾ç¤º -->
                                        <template v-if="searchForm.search_mode === 'context'">
                                            <span style="font-size: 12px; color: #909399; margin-left: 8px;">è¡Œæ•°:</span>
                                            <input type="number" v-model.number="searchForm.context_span"
                                                class="context-span-input" min="0" max="20" :disabled="!selectedLog"
                                                title="ä¸Šä¸‹æ–‡è¡Œæ•°" />
                                        </template>
                                    </div>
                                </div>
                                
                                <!-- æœç´¢æŒ‰é’® - ç§»åˆ°å¤–é¢ -->
                                <button type="button" class="execute-search-btn" @click="executeSearch">
                                    æœç´¢
                                </button>
                            </div>

                            <!-- æ–‡ä»¶è¿‡æ»¤å™¨ (å¸¦è¿‡æ¸¡) -->
                            <transition name="file-filter" @after-enter="updateResultsHeight" @after-leave="updateResultsHeight">
                                <div v-if="searchForm.use_file_filter" style="margin-top:12px;">
                                    <div style="display:flex; gap:16px; flex-wrap:wrap;">
                                        <div v-for="group in groupedFiles" :key="group.key" style="flex:1; min-width:380px; display:flex; flex-direction:column; gap:6px;">
                                            <div style="display:flex; align-items:center; gap:10px;">
                                                <span style="font-size:13px; font-weight:600; color:#409eff; white-space:nowrap;">[[ group.host ]]</span>
                                                <div class="selected-file-box" :class="{ empty: !searchForm.selected_files[group.key] }" style="position:relative; flex:1; padding:6px 34px 6px 10px; border:1px solid #dcdfe6; border-radius:6px; background:#fff; font-size:12px; min-height:34px; display:flex; align-items:center; line-height:1.4; overflow:hidden;">
                                                    <template v-if="searchForm.selected_files[group.key]">
                                                        <span style="word-break:break-all;">[[ formatDisplayPath(searchForm.selected_files[group.key]) ]]</span>
                                                        <span class="clear-icon" @click.stop="clearSelectedFile(group)" style="position:absolute; right:30px; top:50%; transform:translateY(-50%); cursor:pointer; font-size:14px; color:#b1b3b8; line-height:1; padding:2px;" title="æ¸…é™¤">Ã—</span>
                                                    </template>
                                                    <template v-else>
                                                        <span style="color:#909399;">æœªé€‰æ‹©æ–‡ä»¶</span>
                                                    </template>
                                                </div>
                                                <el-button size="small" type="primary" plain style="white-space:nowrap; height:34px; padding:0 14px; display:flex; align-items:center; border-radius:6px;" @click="openSftpBrowser(group)" :disabled="!selectedLog || browsing.loading[group.originalHost]">
                                                    æµè§ˆ
                                                </el-button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </transition>
                            <!-- SFTP æµè§ˆå¯¹è¯æ¡† -->
                            <el-dialog v-model="browsing.visible" title="è¿œç¨‹æ–‡ä»¶æµè§ˆ" width="720px" :close-on-click-modal="false" @close="closeBrowser">
                                <div v-if="browsing.currentHost" style="margin-bottom:8px; font-size:13px; color:#606266; display:flex; flex-wrap:wrap; gap:12px; align-items:center;">
                                    <span>ä¸»æœº: <strong>[[ browsing.currentHost ]]</strong></span>
                                    <span>è·¯å¾„: <code style="font-size:12px; background:#f4f4f5; padding:2px 6px; border-radius:4px;">[[ browsing.currentPath || '/' ]]</code></span>
                                    <el-button size="small" @click="refreshCurrent" :loading="isBrowsingLoading">åˆ·æ–°</el-button>
                                </div>
                                <el-skeleton v-if="isBrowsingLoading" :rows="4" animated></el-skeleton>
                                <div v-else style="max-height:360px; overflow:auto; border:1px solid #ebeef5; border-radius:6px;">
                                    <el-table :key="browsing.currentPath + '_' + browsing.items.length" :data="browsing.items" size="small" @row-dblclick="handleBrowserDblClick" style="width:100%;" height="300" :row-key="row => row.name + '_' + row.type">
                                        <el-table-column label="åç§°" prop="name">
                                            <template #default="scope">
                                                <span v-if="scope.row.is_directory">ğŸ“ [[ scope.row.name ]]</span>
                                                <span v-else>ğŸ“„ [[ scope.row.name ]]</span>
                                            </template>
                                        </el-table-column>
                                        <el-table-column label="ç±»å‹" width="70" prop="type" />
                                        <el-table-column label="å¤§å°" width="100">
                                            <template #default="scope">[[ scope.row.size_human ]]</template>
                                        </el-table-column>
                                        <el-table-column label="ä¿®æ”¹æ—¶é—´" width="180">
                                            <template #default="scope">[[ formatFileTime(scope.row.modified_time) ]]</template>
                                        </el-table-column>
                                    </el-table>
                                    <div v-if="!browsing.items.length" style="padding:12px; text-align:center; color:#909399; font-size:13px;">ç›®å½•ä¸ºç©ºæˆ–æ— æƒé™</div>
                                    <div v-else style="padding:4px 8px; font-size:12px; color:#606266;">å…± [[ browsing.items.length ]] é¡¹</div>
                                </div>
                                <template #footer>
                                    <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                                        <div>
                                            <el-button size="small" @click="goParent" :disabled="!browsing.parentPath">ä¸Šçº§ç›®å½•</el-button>
                                        </div>
                                        <div>
                                            <el-button size="small" @click="closeBrowser">å…³é—­</el-button>
                                        </div>
                                    </div>
                                </template>
                            </el-dialog>
                        </el-form>
                    </div>

                    <!-- æ—¥å¿—ç»“æœæ ‡ç­¾æ  -->
                    <div class="log-tabs-bar" v-if="tabs.length">
                    <div v-for="tab in tabs" :key="tab.id" @click="activateTab(tab.id)"
                        :class="['log-tab-item', { active: tab.id === activeTabId }]">
                            <span class="tab-title" :title="tab.title">[[ tab.title ]]</span>
                            <span v-if="tab.searching" class="tab-badge spinning" title="æœç´¢ä¸­">Â·Â·</span>
                            <span v-else-if="tab.hasSearched && tab.searchResults" class="tab-badge" :title="'åŒ¹é…: '+(tab.searchResults.total_matches||0)">[[ tab.searchResults.total_matches ]]</span>
                            <span class="close" @click.stop="closeTab(tab.id)" title="å…³é—­">Ã—</span>
                        </div>
                    </div>

                    <!-- æœç´¢ç»“æœåŒºåŸŸ -->
                    <div class="results-section" ref="resultsWrapper">

                        <!-- ä½¿ç”¨æ—¥å¿—æœç´¢ç»“æœç»„ä»¶ï¼ˆä»…åœ¨æœç´¢å®Œæˆåè¿›è¡Œé«˜äº®ï¼‰ -->
                        <log-search-results
                            :key="activeTab ? activeTab.resultsVersion : resultsVersion"
                            :search-results="activeTab ? activeTab.searchResults : searchResults"
                            :search-keyword="activeTab ? activeTab.highlightKeyword : highlightKeyword"
                            :use-regex="searchForm.use_regex"
                            :height="searchResultsHeight"
                            :max-results="5000"
                            :show-search-stats="false"
                            :show-host-grouping="true"
                            :enabled-highlighters="effectiveHighlighters"
                            empty-message="æœªæ‰¾åˆ°åŒ¹é…çš„æ—¥å¿—è®°å½•"
                        />
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;
        const { ElMessage, ElMessageBox, ElLoading } = ElementPlus;

        const app = createApp({
            delimiters: ['[[', ']]'],
            components: {
                LogSearchResults
            },
            data() {
                return {
                    logs: [],
                    selectedLog: null,
                    logsLoading: false,
                    searching: false,
                    hasSearched: false,
                    resultsVersion: 0, // æ¯æ¬¡æœç´¢é€’å¢ä»¥é‡å»ºç»“æœç»„ä»¶ï¼Œé‡Šæ”¾å†…å­˜
                    highlightKeyword: '', // ä»…åœ¨æœç´¢å®Œæˆåç”¨äºé«˜äº®çš„å…³é”®è¯
                    searchInputFocused: false,
                    availableFiles: [], // å¯ç”¨æ–‡ä»¶åˆ—è¡¨ (åŸºäºæ—¥å¿—é…ç½®è¿”å›)
                    browsing: {
                        visible: false,
                        currentHost: '',
                        currentHostIndex: -1,
                        currentPath: '',
                        parentPath: null,
                        items: [],
                        connectionIds: {}, // host -> connection_id
                        loading: {}
                    },
                    filesLoading: false, // æ–‡ä»¶åˆ—è¡¨åŠ è½½çŠ¶æ€
                    collapsedGroups: new Set(), // æŠ˜å çš„åˆ†ç»„
                    showMoreMenu: false, // æ›´å¤šèœå•æ˜¾ç¤ºçŠ¶æ€
                    dynamicResultsHeight: '400px', // åŠ¨æ€ç»“æœé«˜åº¦
                    searchForm: {
                        keyword: '',
                        search_mode: 'context', // keyword æˆ– context
                        context_span: 5,
                        use_regex: false,
                        reverse_order: false,
                        use_file_filter: false,
                        selected_file: '',  // ä¿æŒå‘åå…¼å®¹
                        selected_files: {},  // æ–°å¢ï¼šä¸»æœºåˆ°æ–‡ä»¶çš„æ˜ å°„
                        max_lines: 2000 // æ¯æ¬¡æœç´¢çš„æœ€å¤§è¡Œæ•°
                    },
                    searchResults: null,
                    // å¤šæ ‡ç­¾ç®¡ç†
                    tabs: [],
                    activeTabId: null,
                    nextTabSeq: 1
                };
            },

            computed: {
                // æŒ‰åˆ†ç»„ç»„ç»‡çš„æ—¥å¿—åˆ—è¡¨
                groupedLogs() {
                    const groups = {};
                    this.logs.forEach(log => {
                        const groupName = log.group || 'é»˜è®¤åˆ†ç»„';
                        if (!groups[groupName]) {
                            groups[groupName] = [];
                        }
                        groups[groupName].push(log);
                    });

                    return Object.keys(groups).map(groupName => ({
                        name: groupName,
                        logs: groups[groupName].sort((a, b) => a.name.localeCompare(b.name)),
                        isCollapsed: this.collapsedGroups.has(groupName)
                    })).sort((a, b) => {
                        // é»˜è®¤åˆ†ç»„æ’åœ¨æœ€å
                        if (a.name === 'é»˜è®¤åˆ†ç»„' && b.name !== 'é»˜è®¤åˆ†ç»„') return 1;
                        if (b.name === 'é»˜è®¤åˆ†ç»„' && a.name !== 'é»˜è®¤åˆ†ç»„') return -1;
                        return a.name.localeCompare(b.name);
                    });
                },
                
                // æŒ‰ä¸»æœº(å«é‡å¤IP)åˆ†ç»„çš„æ–‡ä»¶åˆ—è¡¨ï¼ŒåŒºåˆ†åŒä¸€IPçš„å¤šä¸ª SSH é…ç½®
                groupedFiles() {
                    if (!this.selectedLog || !this.selectedLog.sshs || !this.selectedLog.sshs.length) {
                        return [];
                    }
                    const sshs = this.selectedLog.sshs;
                    const hostCount = {};
                    sshs.forEach(s => { const h = s.host || 'unknown'; hostCount[h] = (hostCount[h] || 0) + 1; });
                    const groups = [];
                    sshs.forEach((s, idx) => {
                        const host = s.host || 'unknown';
                        const displayHost = hostCount[host] > 1 ? `${host}#${idx + 1}` : host;
                        const key = `${host}|${idx}`; // ä¼ ç»™åç«¯çš„å”¯ä¸€é”®
                        let files = [];
                        // è‹¥å½“å‰æµè§ˆçª—å£æŒ‡å‘è¯¥ ssh indexï¼Œåˆå¹¶æµè§ˆç›®å½•ä¸­çš„æ–‡ä»¶ï¼ˆéç›®å½•ï¼‰
                        if (this.browsing.currentHost === host && this.browsing.currentHostIndex === idx && this.browsing.items.length) {
                            const fileItems = this.browsing.items.filter(i => !i.is_directory).map(i => ({
                                host,
                                filename: i.name,
                                full_path: (this.browsing.currentPath === '/' ? '/' : this.browsing.currentPath + '/') + i.name
                            }));
                            const existing = new Set(files.map(f => f.full_path));
                            fileItems.forEach(f => { if (!existing.has(f.full_path)) files.push(f); });
                        }
                        files.sort((a, b) => a.filename.localeCompare(b.filename));
                        groups.push({ key, host: displayHost, originalHost: host, sshIndex: idx, files });
                    });
                    return groups;
                },
                isBrowsingLoading() {
                    if (!this.browsing || !this.browsing.currentHost) return false;
                    return !!this.browsing.loading[this.browsing.currentHost];
                },

                // å½“å‰æ¿€æ´»æ ‡ç­¾
                activeTab() { return this.tabs.find(t => t.id === this.activeTabId) || null; },

                // é«˜äº®å™¨å¼€å…³ï¼šä»…åœ¨æœç´¢å®Œæˆåå¯ç”¨ï¼ˆæŒ‰å½“å‰æ ‡ç­¾ï¼‰
                effectiveHighlighters() {
                    const tab = this.activeTab;
                    if (!tab || !tab.hasSearched || tab.searching || !tab.searchResults) {
                        return {
                            logLevels: false,
                            timestamps: false,
                            network: false,
                            xml: false,
                            sql: false,
                            json: false,
                            filePaths: false,
                            urls: false,
                            emails: false,
                            uuids: false
                        };
                    }
                    return {
                        logLevels: true,
                        timestamps: true,
                        network: true,
                        xml: true,
                        sql: true,
                        json: true,
                        filePaths: true,
                        urls: true,
                        emails: true,
                        uuids: true
                    };
                },

                // ç»“æœé«˜åº¦ç”±æµ‹é‡é©±åŠ¨
                searchResultsHeight() { return this.dynamicResultsHeight; },

                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¿…éœ€çš„æ–‡ä»¶éƒ½å·²é€‰æ‹©
                isFileFilterValid() {
                    // ä¸å†è‡ªåŠ¨åŠ è½½æ–‡ä»¶åˆ—è¡¨ï¼Œæ”¹ä¸ºçº¯ SFTP æµè§ˆé€‰æ‹©

                    // æ£€æŸ¥æ¯ä¸ªä¸»æœºæ˜¯å¦éƒ½é€‰æ‹©äº†æ–‡ä»¶
                    return this.groupedFiles.every(group =>
                        this.searchForm.selected_files[group.host]
                    );
                }
            },

            mounted() {
                this.loadLogs();

                // æ·»åŠ å…¨å±€å›è½¦é”®ç›‘å¬
                document.addEventListener('keydown', this.handleGlobalKeydown);
                
                // æ·»åŠ ç‚¹å‡»å¤–éƒ¨å…³é—­èœå•çš„ç›‘å¬
                document.addEventListener('click', this.handleClickOutside);

                // åˆæ¬¡è®¡ç®—é«˜åº¦
                this.$nextTick(() => this.updateResultsHeight());
                window.addEventListener('resize', this.updateResultsHeight, { passive: true });

                // å¦‚æœé€šè¿‡ç‹¬ç«‹é¡µé¢è¿›å…¥ (sftp / terminals / config)
                if (window.APP_PAGE && ['sftp','terminals','config'].includes(window.APP_PAGE)) {
                    // å»¶è¿Ÿè®©ç»„ä»¶åˆå§‹åŒ–å®Œæˆ
                    setTimeout(()=>{ this.navigateToPage(window.APP_PAGE); }, 300);
                }
            },

            beforeUnmount() {
                // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
                document.removeEventListener('keydown', this.handleGlobalKeydown);
                document.removeEventListener('click', this.handleClickOutside);
                window.removeEventListener('resize', this.updateResultsHeight);
            },

            methods: {
                // é€šç”¨é”™è¯¯å¤„ç†æ–¹æ³•
                handleApiError(error, defaultMessage = 'æ“ä½œå¤±è´¥') {
                    const errorInfo = error.response?.data?.error || error.error || {};
                    let errorMessage = defaultMessage;
                    
                    // æ ¹æ®é”™è¯¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„æ¶ˆæ¯
                    switch (errorInfo.code) {
                        case 'VALIDATION_ERROR':
                            errorMessage = `å‚æ•°é”™è¯¯: ${errorInfo.message}`;
                            break;
                        case 'INVALID_CONTEXT_SPAN':
                            errorMessage = 'ä¸Šä¸‹æ–‡è¡Œæ•°è®¾ç½®æ— æ•ˆï¼Œè¯·è®¾ç½®ä¸º0-50ä¹‹é—´çš„æ•´æ•°';
                            break;
                        case 'INVALID_SEARCH_MODE':
                            errorMessage = 'æœç´¢æ¨¡å¼æ— æ•ˆï¼Œè¯·é€‰æ‹©æ­£ç¡®çš„æœç´¢æ–¹å¼';
                            break;
                        case 'INVALID_FILE_FILTER':
                            errorMessage = 'æ–‡ä»¶è¿‡æ»¤è®¾ç½®æ— æ•ˆï¼Œå¯ç”¨è¿‡æ»¤æ—¶è¯·æŒ‡å®šè¦æœç´¢çš„æ–‡ä»¶';
                            break;
                        case 'CONNECTION_ERROR':
                            errorMessage = `è¿æ¥å¤±è´¥: ${errorInfo.message || 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'}`;
                            break;
                        case 'DEADLINE_EXCEEDED':
                            errorMessage = `æ“ä½œè¶…æ—¶: ${errorInfo.message || 'è¯·ç¨åé‡è¯•'}`;
                            break;
                        case 'NOT_FOUND':
                            // é’ˆå¯¹ä¸åŒåœºæ™¯æä¾›æ›´å…·ä½“çš„é”™è¯¯æ¶ˆæ¯
                            if (defaultMessage.includes('æ—¥å¿—')) {
                                errorMessage = 'æ—¥å¿—é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆé…ç½®æ—¥å¿—';
                            } else {
                                errorMessage = errorInfo.message || 'èµ„æºä¸å­˜åœ¨';
                            }
                            break;
                        case 'PERMISSION_DENIED':
                            // é’ˆå¯¹ä¸åŒåœºæ™¯æä¾›æ›´å…·ä½“çš„é”™è¯¯æ¶ˆæ¯
                            if (defaultMessage.includes('æ—¥å¿—')) {
                                errorMessage = 'æƒé™ä¸è¶³ï¼Œæ— æ³•è®¿é—®æ—¥å¿—é…ç½®';
                            } else if (defaultMessage.includes('æ–‡ä»¶')) {
                                errorMessage = 'æƒé™ä¸è¶³ï¼Œæ— æ³•è®¿é—®æ–‡ä»¶åˆ—è¡¨';
                            } else {
                                errorMessage = `æƒé™ä¸è¶³: ${errorInfo.message || 'è¯·è”ç³»ç®¡ç†å‘˜'}`;
                            }
                            break;
                        case 'INTERNAL':
                            errorMessage = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
                            break;
                        default:
                            errorMessage = errorInfo.message || defaultMessage;
                    }
                    
                    ElMessage.error(errorMessage);
                    
                    // å¦‚æœæ˜¯è°ƒè¯•æ¨¡å¼ï¼Œæ‰“å°è¯¦ç»†é”™è¯¯ä¿¡æ¯
                    if (errorInfo.details) {
                        console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', errorInfo.details);
                    }
                },

                // å…¨å±€é”®ç›˜äº‹ä»¶å¤„ç†
                handleGlobalKeydown(event) {
                    // æŒ‰ä¸‹å›è½¦é”®ä¸”ä¸åœ¨è¾“å…¥æ¡†ã€æ–‡æœ¬åŸŸæˆ–å…¶ä»–å¯ç¼–è¾‘å…ƒç´ ä¸­
                    if (event.key === 'Enter' &&
                        !['INPUT', 'TEXTAREA'].includes(event.target.tagName) &&
                        !event.target.isContentEditable) {

                        // é˜²æ­¢é»˜è®¤è¡Œä¸ºå’Œäº‹ä»¶å†’æ³¡
                        event.preventDefault();
                        event.stopPropagation();

                        // æ‰§è¡Œæœç´¢
                        this.executeSearch();
                    }
                    
                    // æŒ‰ESCé”®å…³é—­æ›´å¤šèœå•
                    if (event.key === 'Escape' && this.showMoreMenu) {
                        this.showMoreMenu = false;
                    }
                },

                // ç‚¹å‡»å¤–éƒ¨å…³é—­èœå•
                handleClickOutside(event) {
                    // æ£€æŸ¥ç‚¹å‡»æ˜¯å¦åœ¨æ›´å¤šæŒ‰é’®åŒºåŸŸå¤–
                    const moreActions = event.target.closest('.more-actions');
                    if (!moreActions && this.showMoreMenu) {
                        this.showMoreMenu = false;
                    }
                },

                // åˆ†ç»„æŠ˜å /å±•å¼€æ§åˆ¶
                toggleGroup(groupName) {
                    if (this.collapsedGroups.has(groupName)) {
                        this.collapsedGroups.delete(groupName);
                    } else {
                        this.collapsedGroups.add(groupName);
                    }
                },

                // åˆ‡æ¢æ›´å¤šèœå•æ˜¾ç¤ºçŠ¶æ€
                toggleMoreMenu() {
                    this.showMoreMenu = !this.showMoreMenu;
                },

                // é¡µé¢å¯¼èˆª
                navigateToPage(page) {
                    this.showMoreMenu = false; // å…³é—­èœå•
                    
                    // é¡µé¢é…ç½®
                    const pageConfig = {
                        'config': {
                            url: '/config',
                            title: 'æ—¥å¿—é…ç½®',
                            icon: 'âš™ï¸'
                        },
                        'sftp': {
                            url: '/sftp',
                            title: 'æ–‡ä»¶ç®¡ç†',
                            icon: 'ğŸ“'
                        },
                        'terminals': {
                            url: '/terminals',
                            title: 'åœ¨çº¿ç»ˆç«¯',
                            icon: 'ğŸ’»'
                        }
                    };
                    
                    const config = pageConfig[page];
                    if (config) {
                        // æ˜¾ç¤ºå¯¼èˆªæç¤º
                        ElMessage.info(`æ­£åœ¨æ‰“å¼€ ${config.icon} ${config.title}...`);
                        
                        // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´å†æ‰“å¼€ï¼Œè®©ç”¨æˆ·çœ‹åˆ°æç¤º
                        setTimeout(() => {
                            // å¯ä»¥é€‰æ‹©åœ¨æ–°çª—å£æ‰“å¼€æˆ–å½“å‰çª—å£è·³è½¬
                            // æ–°çª—å£æ‰“å¼€ï¼ˆæ¨èï¼‰
                            window.open(config.url, '_blank');
                            
                            // å¦‚æœè¦åœ¨å½“å‰çª—å£è·³è½¬ï¼Œä½¿ç”¨ï¼š
                            // window.location.href = config.url;
                        }, 300);
                    } else {
                        ElMessage.warning(`åŠŸèƒ½ ${page} æš‚æœªå¼€æ”¾`);
                    }
                },

                async loadLogs() {
                    this.logsLoading = true;
                    try {
                        const response = await axios.get('/api/v1/logs');
                        if (response.data.success) {
                            this.logs = response.data.data.logs || [];
                            // é»˜è®¤æŠ˜å æ‰€æœ‰åˆ†ç»„
                            this.collapsedGroups.clear();
                            const groups = new Set();
                            this.logs.forEach(log => {
                                const groupName = log.group || 'é»˜è®¤åˆ†ç»„';
                                groups.add(groupName);
                            });
                            groups.forEach(groupName => {
                                this.collapsedGroups.add(groupName);
                            });
                        } else {
                            this.handleApiError({ response: { data: response.data } }, 'åŠ è½½æ—¥å¿—åˆ—è¡¨å¤±è´¥');
                        }
                    } catch (error) {
                        this.handleApiError(error, 'è¿æ¥æœåŠ¡å™¨å¤±è´¥');
                        console.error('åŠ è½½æ—¥å¿—å¤±è´¥:', error);
                    } finally {
                        this.logsLoading = false;
                    }
                },

                selectLog(log) {
                    if (!log) return;
                    // è‹¥å·²æœ‰å¯¹åº”æ ‡ç­¾åˆ™æ¿€æ´»
                    const exist = this.tabs.find(t => t.logName === log.name);
                    if (exist) { this.activateTab(exist.id); return; }
                    // åˆ›å»ºæ–°æ ‡ç­¾
                    const tab = this._createTabForLog(log);
                    this.tabs.push(tab);
                    this.activeTabId = tab.id;
                    this._syncActiveTabToRoot();
                    // æ„å»ºå ä½ & æ‹‰å–è¯¦æƒ…
                    this.buildPlaceholderResults(tab);
                    this.ensureLogDetail(log).then(()=>{
                        if (tab.searchResults && tab.searchResults.pre_search) {
                            this.buildPlaceholderResults(tab); // æ›´æ–° sshs
                        }
                    });
                },

                // ç¡®ä¿ selectedLog æ‹¥æœ‰ sshsï¼ˆä¸åç«¯ detail æ¥å£å­—æ®µ ssh_configs å¯¹é½ï¼‰
                async ensureLogDetail(log) {
                    if (!log || log.sshs || !log.name) return;
                    try {
                        const resp = await axios.get(`/api/v1/logs/${log.name}`);
                        if (resp.data.success && resp.data.data) {
                            const detail = resp.data.data;
                            // åç«¯è¿”å› ssh_configsï¼›å‰ç«¯ç»Ÿä¸€ä½¿ç”¨ sshs
                            const sshs = detail.ssh_configs || [];
                            // å°† sshs æŒ‚åˆ°åŸ log å¯¹è±¡ä¸Šï¼Œä¿æŒå¼•ç”¨ä¸€è‡´
                            log.sshs = sshs; // Vue3 ç›´æ¥èµ‹å€¼å³å¯è§¦å‘å“åº”
                            // å¦‚æœå½“å‰ selectedLog æŒ‡å‘è¯¥å¯¹è±¡ï¼Œç¡®ä¿å±æ€§å¯ç”¨
                            if (this.selectedLog === log) {
                                this.selectedLog.sshs = sshs;
                                if (!this.hasSearched) {
                                    this.buildPlaceholderResults();
                                }
                            }
                        }
                    } catch (e) {
                        // é™é»˜å¤±è´¥ï¼Œåªåœ¨ç”¨æˆ·çœŸæ­£éœ€è¦æ—¶å†æç¤º
                        console.warn('è·å–æ—¥å¿—è¯¦ç»†é…ç½®å¤±è´¥', e);
                    }
                },

                // åˆ‡æ¢æœç´¢æ¨¡å¼
                toggleSearchMode() {
                    this.searchForm.search_mode = this.searchForm.search_mode === 'keyword' ? 'context' : 'keyword';
                    const mode = this.searchForm.search_mode === 'keyword' ? 'å…³é”®è¯æœç´¢' : 'ä¸Šä¸‹æ–‡æœç´¢';
                    ElMessage.info(`å·²åˆ‡æ¢åˆ°${mode}æ¨¡å¼`);
                },

                // åˆ‡æ¢æ–‡ä»¶è¿‡æ»¤
                toggleFileFilter() {
                    this.searchForm.use_file_filter = !this.searchForm.use_file_filter;
                    if (this.searchForm.use_file_filter) {
                        ElMessage.info('å·²å¯ç”¨æ–‡ä»¶è¿‡æ»¤ï¼Œå¯é€šè¿‡â€œæµè§ˆâ€é€‰æ‹©æ–‡ä»¶');
                    } else {
                        this.searchForm.selected_file = '';
                        this.searchForm.selected_files = {};
                        this.availableFiles = [];
                        ElMessage.info('å·²å…³é—­æ–‡ä»¶è¿‡æ»¤');
                    }
                    this.$nextTick(() => this.updateResultsHeight());
                },

                // åŠ è½½å¯ç”¨æ–‡ä»¶åˆ—è¡¨
                // ï¼ˆåºŸå¼ƒï¼‰loadAvailableFiles å·²ç§»é™¤ï¼Œæ–‡ä»¶æ¥æºç»Ÿä¸€é€šè¿‡ SFTP æµè§ˆå™¨

                // æ‰“å¼€æµè§ˆå™¨ï¼ˆæ”¯æŒåŒIPå¤šå®ä¾‹ï¼Œå‚æ•°ä¸ºåˆ†ç»„å¯¹è±¡æˆ–åŸ host å­—ç¬¦ä¸²ï¼‰
                async openSftpBrowser(groupOrHost) {
                    if (!this.selectedLog) {
                        ElMessage.error('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ—¥å¿—é…ç½®');
                        return;
                    }
                    // è‹¥è¿˜æ²¡æœ‰ sshsï¼Œå°è¯•åŠ è½½ä¸€æ¬¡
                    if (!this.selectedLog.sshs) {
                        await this.ensureLogDetail(this.selectedLog);
                    }
                    if (!this.selectedLog.sshs) {
                        ElMessage.error('å½“å‰æ—¥å¿—é…ç½®ç¼ºå°‘ SSH ä¿¡æ¯');
                        return;
                    }
                    let sshIndex, host;
                    if (typeof groupOrHost === 'string') {
                        host = groupOrHost;
                        sshIndex = this.selectedLog.sshs.findIndex(s => s.host === host);
                    } else {
                        host = groupOrHost.originalHost;
                        sshIndex = groupOrHost.sshIndex;
                    }
                    if (sshIndex == null || sshIndex < 0 || sshIndex >= this.selectedLog.sshs.length) {
                        ElMessage.error('æœªæ‰¾åˆ°å¯¹åº”ä¸»æœº SSH é…ç½®');
                        return;
                    }
                    this.browsing.currentHost = host;
                    this.browsing.currentHostIndex = sshIndex;
                    this.browsing.visible = true;
                    await this.ensureSftpConnection(host, sshIndex);
                    // æ›´æ™ºèƒ½çš„é»˜è®¤è·¯å¾„ï¼š
                    // 1) è‹¥ path å«å ä½ç¬¦ï¼Œå…ˆç”¨å½“å‰æ—¥æœŸæ›¿æ¢ {YYYY}/{MM}/{DD}ï¼Œå¾—åˆ°â€œè§£æåçš„å®Œæ•´æ–‡ä»¶è·¯å¾„â€ï¼Œå–å…¶çˆ¶ç›®å½•ä½œä¸ºé¦–é€‰ç›®å½•ï¼›
                    //    è‹¥è¯¥ç›®å½•ä¸‹æ‰¾ä¸åˆ°ä¸è§£æåæ–‡ä»¶ååŒ¹é…çš„æ–‡ä»¶ï¼ˆæˆ–ç›®å½•ä¸å­˜åœ¨ï¼‰ï¼Œåˆ™å›é€€åˆ°â€œå ä½ç¬¦ä¹‹å‰â€çš„ç›®å½•ã€‚
                    // 2) è‹¥ä¸å«å ä½ç¬¦ï¼šè‹¥æ˜¯æ–‡ä»¶è·¯å¾„åˆ™å–çˆ¶ç›®å½•ï¼Œå¦åˆ™ç›´æ¥ç”¨ç›®å½•ã€‚
                    try {
                        const sshCfg = this.selectedLog.sshs[sshIndex] || {};
                        const originalPath = (sshCfg.path || this.selectedLog.path || '/') || '/';
                        const hasPlaceholder = /\{[^}]+\}/.test(originalPath);

                        const normalizeDir = (p) => {
                            let s = (p || '/').replace(/\/+/g, '/');
                            if (s !== '/' && s.endsWith('/')) s = s.replace(/\/+$/,'');
                            if (!s) s = '/';
                            return s;
                        };
                        const parentDir = (p) => {
                            if (!p) return '/';
                            const i = p.lastIndexOf('/');
                            if (i <= 0) return '/';
                            return p.slice(0, i) || '/';
                        };
                        const pad2 = (n) => (n < 10 ? '0' + n : '' + n);
                        const replaceDatePlaceholders = (p) => {
                            const now = new Date();
                            const YYYY = '' + now.getFullYear();
                            const MM = pad2(now.getMonth() + 1);
                            const DD = pad2(now.getDate());
                            return p
                                .replace(/\{YYYY\}/g, YYYY)
                                .replace(/\{MM\}/g, MM)
                                .replace(/\{DD\}/g, DD);
                        };
                        const escapeRegExp = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const buildNameMatcher = (basename) => {
                            if (basename.includes('{N}')) {
                                const pattern = '^' + escapeRegExp(basename).replace(/\\\{N\\\}/g, '\\d+') + '$';
                                return new RegExp(pattern);
                            }
                            return basename; // exact match string
                        };
                        const probePath = async (h, dir) => {
                            const cid = this.browsing.connectionIds[h];
                            if (!cid) throw new Error('no connection');
                            const resp = await axios.post('/api/v1/sftp/list', { connection_id: cid, path: dir });
                            if (!resp.data.success) throw Object.assign(new Error('list failed'), { response: resp });
                            return resp.data.data;
                        };

                        if (hasPlaceholder) {
                            // è§£ææ—¥æœŸå ä½ç¬¦å¾—åˆ°æœŸæœ›æ–‡ä»¶å
                            const resolvedPath = replaceDatePlaceholders(originalPath);
                            const primaryDir = normalizeDir(parentDir(resolvedPath.endsWith('/') ? resolvedPath.slice(0, -1) : resolvedPath));
                            const baseName = resolvedPath.slice(resolvedPath.lastIndexOf('/') + 1) || '';
                            const nameMatcher = buildNameMatcher(baseName); // RegExp æˆ–å­—ç¬¦ä¸²
                            // å¤‡é€‰ï¼šæˆªæ–­åˆ°ç¬¬ä¸€ä¸ªå ä½ç¬¦ä¹‹å‰ï¼Œå†å–çˆ¶ç›®å½•
                            const phIdx = originalPath.search(/\{[^}]+\}/);
                            let fallbackBase = phIdx >= 0 ? originalPath.slice(0, phIdx) : originalPath;
                            if (!fallbackBase.endsWith('/')) fallbackBase = parentDir(fallbackBase);
                            const fallbackDir = normalizeDir(fallbackBase || '/');

                            try {
                                const data = await probePath(host, primaryDir);
                                const items = Array.isArray(data.items) ? data.items : [];
                                const found = items.some(it => !it.is_directory && (
                                    (nameMatcher instanceof RegExp) ? nameMatcher.test(it.name) : (nameMatcher ? it.name === nameMatcher : false)
                                ));
                                if (found) {
                                    this.listRemotePath(host, primaryDir);
                                    return;
                                }
                                // æ‰¾ä¸åˆ°åŒ¹é…æ–‡ä»¶ï¼Œé€€å›æ›´ä¸Šå±‚ç›®å½•
                                this.listRemotePath(host, fallbackDir);
                            } catch (err) {
                                // ç›®å½•ä¸å­˜åœ¨æˆ–æ— æ³•è®¿é—®ï¼Œç›´æ¥å›é€€
                                this.listRemotePath(host, fallbackDir);
                            }
                        } else {
                            // æ— å ä½ç¬¦ï¼šæ ¹æ®æ˜¯å¦ä¸ºæ–‡ä»¶è·¯å¾„å†³å®šç›®å½•
                            let raw = originalPath;
                            if (!raw.endsWith('/')) raw = parentDir(raw);
                            raw = normalizeDir(raw);
                            this.listRemotePath(host, raw);
                        }
                    } catch (e) {
                        console.warn('è§£æåˆå§‹ç›®å½•å¤±è´¥ï¼Œå›é€€åˆ°æ ¹ç›®å½•', e);
                        this.listRemotePath(host, '.');
                    }
                },
                async ensureSftpConnection(host, sshIndex) {
                    if (this.browsing.connectionIds[host]) return;
                    this.browsing.loading[host] = true;
                    try {
                        const resp = await axios.post('/api/v1/sftp/connect-by-config', { log_name: this.selectedLog.name, ssh_index: sshIndex });
                        if (resp.data.success) {
                            this.browsing.connectionIds[host] = resp.data.data.connection_id;
                        } else {
                            this.handleApiError({ response: { data: resp.data } }, 'SFTPè¿æ¥å¤±è´¥');
                        }
                    } catch (e) {
                        this.handleApiError(e, 'SFTPè¿æ¥è¯·æ±‚å¤±è´¥');
                    } finally {
                        this.browsing.loading[host] = false;
                    }
                },
                async listRemotePath(host, path) {
                    const cid = this.browsing.connectionIds[host];
                    if (!cid) return;
                    this.browsing.loading[host] = true;
                    try {
                        const resp = await axios.post('/api/v1/sftp/list', { connection_id: cid, path });
                        if (resp.data.success) {
                            const data = resp.data.data;
                            this.browsing.currentPath = data.current_path;
                            this.browsing.parentPath = data.parent_path;
                            this.browsing.items = data.items || [];
                        } else {
                            this.handleApiError({ response: { data: resp.data } }, 'åˆ—å‡ºç›®å½•å¤±è´¥');
                        }
                    } catch (e) {
                        this.handleApiError(e, 'åˆ—å‡ºç›®å½•è¯·æ±‚å¤±è´¥');
                    } finally {
                        this.browsing.loading[host] = false;
                    }
                },
        handleBrowserDblClick(row) {
                    if (!row) return;
                    if (row.is_directory) {
                        const p = (this.browsing.currentPath === '/' ? '' : this.browsing.currentPath) + '/' + row.name;
                        this.listRemotePath(this.browsing.currentHost, p);
                    } else {
                        // é€‰ä¸­æ–‡ä»¶å¹¶å…³é—­
                        const full = (this.browsing.currentPath === '/' ? '/' : this.browsing.currentPath + '/') + row.name;
            const key = `${this.browsing.currentHost}|${this.browsing.currentHostIndex}`;
            this.searchForm.selected_files[key] = full;
                        ElMessage.success('å·²é€‰æ‹©æ–‡ä»¶: ' + row.name);
                        this.closeBrowser();
                    }
                },
                goParent() {
                    if (!this.browsing.parentPath) return;
                    this.listRemotePath(this.browsing.currentHost, this.browsing.parentPath);
                },
                closeBrowser() {
                    this.browsing.visible = false;
                },
                refreshCurrent() {
                    if (!this.browsing.currentHost) return;
                    this.listRemotePath(this.browsing.currentHost, this.browsing.currentPath || '.');
                },

                // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°æ˜¾ç¤º
                formatFileSize(bytes) {
                    if (!bytes || bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
                },

                // æ ¼å¼åŒ–æ–‡ä»¶æ—¶é—´æ˜¾ç¤º
                formatFileTime(timeStr) {
                    if (!timeStr) return 'æœªçŸ¥';
                    try {
                        const date = new Date(timeStr);
                        // è¿”å›æ ‡å‡†æ ¼å¼ï¼šYYYY-MM-DD HH:mm:ss
                        return date.toLocaleString('zh-CN', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit',
                            hour12: false
                        });
                    } catch (e) {
                        return timeStr;
                    }
                },
                formatDisplayPath(p) {
                    if (!p) return '';
                    // ç®€å•æˆªæ–­è¿‡é•¿è·¯å¾„ä¸­é—´éƒ¨åˆ†
                    if (p.length > 80) {
                        return p.slice(0, 35) + ' ... ' + p.slice(-35);
                    }
                    return p;
                },
                clearSelectedFile(group) {
                    if (!group) return;
                    this.$delete ? this.$delete(this.searchForm.selected_files, group.key) : (delete this.searchForm.selected_files[group.key]);
                },

                async executeSearch() {
                    const tab = this.activeTab;
                    if (!tab || !this.selectedLog) {
                        ElMessage.warning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ—¥å¿—é…ç½®');
                        return;
                    }

                    // éªŒè¯æ–‡ä»¶è¿‡æ»¤è®¾ç½®
                    // è‹¥å¼€å¯æ–‡ä»¶è¿‡æ»¤ä½†æœªä¸ºæ‰€æœ‰ä¸»æœºé€‰æ–‡ä»¶ï¼Œå…è®¸ç»§ç»­ï¼šæœªé€‰æ‹©çš„ä¸»æœº fallback åˆ°é»˜è®¤é…ç½®è·¯å¾„
                    if (this.searchForm.use_file_filter) {
                        const totalHosts = this.groupedFiles.length;
                        const chosen = Object.keys(this.searchForm.selected_files || {}).length;
                        if (chosen === 0) {
                            ElMessage.info('æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶ï¼Œå°†ä½¿ç”¨é…ç½®é»˜è®¤è·¯å¾„');
                        } else if (chosen < totalHosts) {
                            ElMessage.info(`éƒ¨åˆ†ä¸»æœºæœªé€‰æ–‡ä»¶ï¼ˆ${chosen}/${totalHosts}ï¼‰ï¼Œæœªé€‰çš„å°†ç”¨é»˜è®¤è·¯å¾„`);
                        }
                    }

                    // è¿›å…¥æœç´¢ï¼šå…ˆå±•ç¤ºå ä½æ¡†é¿å…é—ªçƒ
                    this.buildPlaceholderResults(tab);
                    tab.highlightKeyword = '';
                    await this.$nextTick();

                    tab.searching = true;
                    tab.hasSearched = true;

                    try {
                        const response = await axios.post(`/api/v1/logs/${this.selectedLog.name}/search`, this.searchForm);

                        if (response.data.success) {
                            tab.searchResults = response.data.data;
                            if (tab.searchResults) tab.searchResults.pre_search = false;
                            tab.highlightKeyword = this.searchForm.keyword || '';
                            tab.resultsVersion += 1;
                            if (tab.searchResults.total_matches === 0) {
                                ElMessage.info('æœªæ‰¾åˆ°åŒ¹é…çš„æ—¥å¿—è®°å½•');
                            } else {
                                ElMessage.success(`æ‰¾åˆ° ${tab.searchResults.total_matches} ä¸ªåŒ¹é…é¡¹`);
                            }
                        } else {
                            this.handleApiError({ response: { data: response.data } }, 'æœç´¢å¤±è´¥');
                            tab.searchResults = null;
                            tab.highlightKeyword = '';
                        }
                    } catch (error) {
                        this.handleApiError(error, 'æœç´¢è¯·æ±‚å¤±è´¥');
                        console.error('æœç´¢å¤±è´¥:', error);
                        tab.searchResults = null;
                        tab.highlightKeyword = '';
                    } finally {
                        tab.searching = false;
                        this.$nextTick(() => this.updateResultsHeight());
                    }
                },
                // æ„å»ºå ä½ç»“æœæ¡†ï¼ˆæ˜¾ç¤ºæ¯ä¸ªä¸»æœºç©ºå®¹å™¨ï¼‰
                buildPlaceholderResults(tab = null) {
                    tab = tab || this.activeTab;
                    if (!tab) return;
                    const logRef = tab.selectedLog || this.selectedLog;
                    if (!logRef || !logRef.sshs || !logRef.sshs.length) {
                        tab.searchResults = null;
                        tab.resultsVersion += 1;
                        if (tab.id === this.activeTabId) { this.searchResults = null; this.resultsVersion = tab.resultsVersion; }
                        return;
                    }
                    const hosts = logRef.sshs.map((s, idx) => ({
                        host: s.host || 'unknown',
                        ssh_index: idx,
                        results: [],
                        total_results: 0,
                        search_time: 0,
                        search_result: { content: '', file_path: '', keyword: '', total_lines: 0, search_time: 0, matches: [] },
                        success: true
                    }));
                    tab.searchResults = {
                        log_name: logRef.name,
                        keyword: '',
                        search_params: {},
                        total_hosts: hosts.length,
                        hosts,
                        total_results: 0,
            total_matches: 0,
                        total_search_time: 0,
            parallel_execution: false,
            pre_search: true
                    };
                    tab.resultsVersion += 1;
                    if (tab.id === this.activeTabId) {
                        this.searchResults = tab.searchResults;
                        this.resultsVersion = tab.resultsVersion;
                    }
                },
                // åˆ›å»ºæ ‡ç­¾å¯¹è±¡
                _createTabForLog(log) {
                    return {
                        id: 'tab_' + (this.nextTabSeq++),
                        logName: log.name,
                        title: log.name,
                        selectedLog: log,
                        searchForm: JSON.parse(JSON.stringify(this._defaultSearchForm())),
                        searchResults: null,
                        highlightKeyword: '',
                        hasSearched: false,
                        searching: false,
                        resultsVersion: 0
                    };
                },
                _defaultSearchForm() {
                    return {
                        keyword: '',
                        search_mode: 'context',
                        context_span: 5,
                        use_regex: false,
                        reverse_order: false,
                        use_file_filter: false,
                        selected_file: '',
                        selected_files: {},
                        max_lines: 2000
                    };
                },
                activateTab(id) {
                    if (this.activeTabId === id) return;
                    const tab = this.tabs.find(t => t.id === id);
                    if (!tab) return;
                    this.activeTabId = id;
                    this._syncActiveTabToRoot();
                    this.$nextTick(() => this.updateResultsHeight());
                },
                closeTab(id) {
                    const idx = this.tabs.findIndex(t => t.id === id);
                    if (idx === -1) return;
                    const closingActive = this.tabs[idx].id === this.activeTabId;
                    this.tabs.splice(idx,1);
                    if (!this.tabs.length) {
                        // é‡ç½®å…¨å±€
                        this.selectedLog = null;
                        this.activeTabId = null;
                        this.searchForm = this._defaultSearchForm();
                        this.searchResults = null;
                        this.highlightKeyword='';
                        this.hasSearched=false;
                    } else if (closingActive) {
                        const newTab = this.tabs[Math.max(0, idx-1)];
                        this.activeTabId = newTab.id;
                        this._syncActiveTabToRoot();
                    }
                },
                _syncActiveTabToRoot() {
                    const tab = this.activeTab;
                    if (!tab) return;
                    this.selectedLog = tab.selectedLog;
                    this.searchForm = tab.searchForm;
                    this.searchResults = tab.searchResults;
                    this.highlightKeyword = tab.highlightKeyword;
                    this.hasSearched = tab.hasSearched;
                    this.searching = tab.searching;
                    this.resultsVersion = tab.resultsVersion;
                },
                tabStyle() { return {}; }
                ,
                updateResultsHeight() {
                    try {
                        const wrapper = this.$refs.resultsWrapper;
                        if (!wrapper) return;
                        const wrapperRect = wrapper.getBoundingClientRect();
                        // ä»¥ right-panel å®¹å™¨åº•éƒ¨ä¸ºç•Œé™ï¼ˆé¿å…çª—å£å†…å…¶å®ƒ padding å½±å“ï¼‰
                        const parentPanel = wrapper.closest('.right-panel');
                        let availableHeight;
                        if (parentPanel) {
                            const panelRect = parentPanel.getBoundingClientRect();
                            // ç•™å‡ºä¸åº•éƒ¨ç»Ÿä¸€é—´è·
                            const bottomGap = 16;
                            // å‡å»è‡ªèº« padding-bottomï¼Œé˜²æ­¢æ’‘å‡ºçˆ¶å®¹å™¨
                            const wrapperStyles = window.getComputedStyle(wrapper);
                            const paddingBottom = parseInt(wrapperStyles.paddingBottom) || 0;
                            availableHeight = panelRect.bottom - wrapperRect.top - bottomGap - paddingBottom;
                        } else {
                            const bottomGap = 16;
                            availableHeight = window.innerHeight - wrapperRect.top - bottomGap;
                        }
                        // å‡å»å¤´éƒ¨é«˜åº¦ï¼ˆæ ‡é¢˜ä¸ç»Ÿè®¡æ ‡ç­¾åŒºåŸŸï¼‰
                        const headerEl = wrapper.querySelector('.results-section-header');
                        let headerH = 0;
                        if (headerEl) {
                            const hr = headerEl.getBoundingClientRect();
                            headerH = hr.height + 4; // é¢å¤–ç•™ 4px é—´è·
                        }
                        availableHeight -= headerH;
                        if (availableHeight < 120) availableHeight = 120; // ä¿åº•
                        // è‹¥æœ‰æ–‡ä»¶è¿‡æ»¤å™¨å¤„äºå±•å¼€çŠ¶æ€ï¼Œå…¶åŠ¨ç”»å¯èƒ½å°šæœªç»“æŸï¼Œç¨åšè¡¥å¿å†æ¬¡åˆ·æ–°
                        const minH = 200;
                        this.dynamicResultsHeight = Math.max(minH, availableHeight) + 'px';
                        // åŠ¨ç”»è¿‡ç¨‹ä¸­å†æ¬¡æµ‹é‡ï¼ˆé¿å…é¦–æ¬¡é«˜åº¦ç®—å¤§/ç®—å°ï¼‰
                        requestAnimationFrame(() => {
                            const w2 = this.$refs.resultsWrapper;
                            if (!w2) return;
                            const wr2 = w2.getBoundingClientRect();
                            const pp2 = w2.closest('.right-panel');
                            if (pp2) {
                                const pr2 = pp2.getBoundingClientRect();
                                const gap = 16;
                                const w2Styles = window.getComputedStyle(w2);
                                const padB2 = parseInt(w2Styles.paddingBottom) || 0;
                                const avail2 = pr2.bottom - wr2.top - gap - padB2;
                                const header2 = w2.querySelector('.results-section-header');
                                if (header2) {
                                    const h2 = header2.getBoundingClientRect().height + 4;
                                    avail2 -= h2;
                                }
                                this.dynamicResultsHeight = Math.max(minH, avail2) + 'px';
                            }
                        });
                    } catch(e) { /* ignore */ }
                }
            }
        });

        // ä½¿ç”¨ Element Plus å’Œå…¶æŒ‡ä»¤
        app.use(ElementPlus);

        // æŒ‚è½½åº”ç”¨
        app.mount('#app');
    </script>
</body>

</html>