# 日志搜索截断流程图

## 📊 简化流程

```
用户发起搜索
    ↓
前端构造参数
    ├─ keyword: "ERROR"
    ├─ reverse_order: true/false
    └─ max_lines: 2000 (默认)
    ↓
后端接收请求
    ↓
构建远程命令 (_compose_command)
    ↓
┌─────────────────────────────────────┐
│  第一层截断：远程命令层              │
├─────────────────────────────────────┤
│                                     │
│  正序 (reverse_order=false):       │
│  grep ... | head -n 10000          │
│  → 返回最早的 10,000 行             │
│                                     │
│  逆序 (reverse_order=true):        │
│  grep ... | tail -n 10000 | tac   │
│  → 返回最新的 10,000 行（已反转）   │
│                                     │
└─────────────────────────────────────┘
    ↓
执行 SSH 命令，获取结果
    ↓
解析输出 (_parse_grep_output)
    ↓
检查行数: len(results)
    ↓
┌─────────────────────────────────────┐
│  第二层截断：后端应用层              │
├─────────────────────────────────────┤
│                                     │
│  if len(results) > max_lines:      │
│                                     │
│    正序 (reverse_order=false):     │
│    results = results[-2000:]       │
│    → 保留时间最新的 2000 行         │
│                                     │
│    逆序 (reverse_order=true):      │
│    results = results[:2000]        │
│    → 保留已反转的前 2000 行         │
│                                     │
│    truncated = True                │
│                                     │
└─────────────────────────────────────┘
    ↓
记录元数据
    ├─ total_lines: 2000
    ├─ original_total_lines: 10000
    └─ truncated: True
    ↓
返回给前端
    ↓
前端渲染结果
```

---

## 🔢 数值示例

### 场景：100,000 行日志，搜索 "ERROR"

```
原始日志文件
[100,000 行]
    ↓
远程命令：grep "ERROR" file.log | head -n 10000
    ↓
[10,000 行] ← 第一次截断（远程）
    ↓
后端检查：10000 > 2000 ?
    ↓ Yes
后端截断：results[-2000:]
    ↓
[2,000 行] ← 第二次截断（后端）
    ↓
返回前端
```

**结果**:
- 前端显示: 2,000 行
- 元数据显示: "原始 10,000 行，已截断到 2,000 行"
- 用户看到: 第 8,001 - 10,000 个匹配（最新的）

---

## 🎯 核心规则

### 规则 1: 优先保留最新日志

| 搜索模式  | 远程命令           | 后端截断        | 结果       |
|-----------|-------------------|----------------|------------|
| 正序      | head -n 10000     | results[-2000:] | 最新 2000 行 |
| 逆序      | tail -n 10000 + tac | results[:2000] | 最新 2000 行 |

**关键**: 无论哪种方式，都是时间最新的日志

### 规则 2: 双层截断互补

```
远程截断 (10,000) → 减少网络传输，保护远程系统
后端截断 (2,000)  → 保护前端性能，优化用户体验
```

### 规则 3: 元数据完整记录

```python
{
    "total_lines": 2000,              # 最终返回行数
    "original_total_lines": 10000,    # 截断前行数
    "truncated": true                 # 是否发生截断
}
```

---

## 🔧 配置调整

### 修改远程截断限制

**文件**: `app/services/log/search.py`

```python
# 修改这个常量
MAX_GREP_LINES_LIMIT = 10000  # 改为你想要的值，如 20000
```

**影响**: 所有搜索请求的远程命令都会使用新的限制

### 修改后端截断限制

**文件**: `templates/index.html`

```javascript
// 修改这个常量
const CONSTANTS = {
    MAX_LINES: 2000  // 改为你想要的值，如 5000
};
```

**影响**: 前端发送请求时的默认 `max_lines` 参数

### 动态调整（推荐）

前端可以在每次搜索时指定不同的 `max_lines`:

```javascript
searchForm: {
    keyword: 'ERROR',
    max_lines: 5000  // 本次搜索使用 5000 行限制
}
```

---

## ⚡ 性能影响

### 增加限制的影响

| 限制值 | 网络传输 | 后端处理 | 前端渲染 | 用户体验 |
|--------|---------|---------|---------|---------|
| 1,000  | 快      | 快      | 流畅     | ⭐⭐⭐⭐⭐ |
| 2,000  | 快      | 快      | 流畅     | ⭐⭐⭐⭐⭐ |
| 5,000  | 中等    | 中等    | 良好     | ⭐⭐⭐⭐ |
| 10,000 | 慢      | 慢      | 可接受   | ⭐⭐⭐ |
| 20,000 | 很慢    | 很慢    | 较卡     | ⭐⭐ |

**建议**: 
- 日常使用: 2,000 行
- 详细分析: 5,000 行
- 特殊场景: 10,000 行
- 不建议超过 20,000 行

---

## 🐛 常见问题

### Q1: 为什么我搜索到的结果不完整？

**A**: 可能触发了截断机制

**检查方法**:
1. 查看响应中的 `truncated` 字段
2. 对比 `original_total_lines` 和 `total_lines`
3. 查看 `aggregated_truncation` 信息

**解决方案**:
- 使用更精确的关键词缩小范围
- 调整前端 `MAX_LINES` 配置
- 使用时间范围过滤（如果支持）

### Q2: 逆序搜索和正序搜索的结果为什么不一样？

**A**: 这是正常的！

- **正序**: 保留远程返回的最后 2000 行
- **逆序**: 保留远程返回的前 2000 行（已反转）

**如果远程返回了完整结果（< 10,000）**: 两者应该相同（只是顺序相反）

**如果触发远程截断（> 10,000）**: 两者会不同
- 正序: 看到中间靠后的匹配
- 逆序: 看到最新的匹配

### Q3: 多主机搜索时，每台主机的截断是独立的吗？

**A**: 是的！

每台主机独立执行：
1. 独立的远程命令截断（各自 10,000 行）
2. 独立的后端截断（各自 max_lines 行）

聚合信息中会记录每台主机的截断情况。

---

**快速参考**: 默认情况下，用户最多看到 `主机数 × 2000` 行日志
